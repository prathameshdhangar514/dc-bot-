# AP I Health monitoring
@tasks.loop(minutes=5)
async def api_health_monitor():
    """Monitor API usage and rate limiting status"""
    try:
        now = time.time()

        # Clean old API call records
        global discord_api_calls
        discord_api_calls = [
            call_time for call_time in discord_api_calls
            if now - call_time < API_WINDOW
        ]

        # IMPROVED CLEANUP - Add size limits
        for user_id in list(user_command_cooldowns.keys()):
            user_commands = user_command_cooldowns[user_id]

            # Remove expired cooldowns
            for command in list(user_commands.keys()):
                if now - user_commands[command] > 86400:  # 24 hours
                    del user_commands[command]

            # Remove empty user records
            if not user_commands:
                del user_command_cooldowns[user_id]

        # CRITICAL: Prevent memory explosion - limit total entries
        if len(user_command_cooldowns) > 10000:  # Safety limit
            logger.warning(
                "‚ö†Ô∏è Cooldown dictionary too large, clearing old entries")
            # Keep only the 1000 most recent entries
            sorted_users = sorted(user_command_cooldowns.items(),
                                  key=lambda x: max(x[1].values())
                                  if x[1] else 0,
                                  reverse=True)
            user_command_cooldowns.clear()
            user_command_cooldowns.update(dict(sorted_users[:1000]))

    except Exception as e:
        logger.error(f"‚ùå API health monitor error: {e}")


async def main():
    """Main async function with proper startup sequence and error recovery"""
    global bot
    logger.info("üöÄ Starting Discord Bot...")

    # Check if TOKEN is valid before proceeding
    if not TOKEN:
        logger.critical("‚ùå DISCORD_BOT_TOKEN not set in environment variables")
        logger.critical(
            "Please set your Discord bot token in the environment variables")
        return

    max_connection_retries = 5
    retry_delay = 10  # seconds

    for attempt in range(max_connection_retries):
        try:
            # Test connection first
            logger.info(
                f"üîç Testing connection (attempt {attempt + 1}/{max_connection_retries})..."
            )

            if not await test_bot_connection():
                logger.error("‚ùå Bot token validation failed")
                if attempt < max_connection_retries - 1:
                    logger.info(f"‚è≥ Retrying in {retry_delay} seconds...")
                    await asyncio.sleep(retry_delay)
                    continue
                else:
                    logger.error("‚ùå All connection attempts failed")
                    return

            # Create startup backup
            await startup_backup()

            # Start the bot
            logger.info("ü§ñ Starting Discord bot connection...")
            await bot.start(TOKEN)
            break  # If we get here, bot started successfully

        except discord.LoginFailure:
            logger.error("‚ùå Invalid bot token")
            break

        except discord.HTTPException as e:
            logger.error(f"‚ùå Discord HTTP error: {e}")
            if attempt < max_connection_retries - 1:
                logger.info(f"‚è≥ Retrying in {retry_delay} seconds...")
                await asyncio.sleep(retry_delay)
                retry_delay = min(retry_delay * 2, 300)  # Exponential backoff with max delay
            else:
                logger.error("‚ùå Max retries exceeded")

        except KeyboardInterrupt:
            logger.info("üõë Keyboard interrupt received")
            break

        except Exception as e:
            logger.error(f"‚ùå Unexpected bot error: {e}")
            if attempt < max_connection_retries - 1:
                logger.info(f"‚è≥ Retrying in {retry_delay} seconds...")
                await asyncio.sleep(retry_delay)
                retry_delay = min(retry_delay * 2, 300)  # Exponential backoff with max delay
            else:
                logger.error("‚ùå Max retries exceeded")

    # Cleanup
    try:
        if bot and not bot.is_closed():
            logger.info("üõë Closing bot connection...")
            await bot.close()
    except Exception as e:
        logger.error(f"‚ùå Error during cleanup: {e}")

    logger.info("üõë Bot shutdown complete")


# ==== Flask Setup ====
app = Flask(__name__)


@app.route('/')
def home():
    return "Bot is alive!"


@app.route('/health')
def enhanced_health():
    """Enhanced health check with detailed status"""
    status = {"status": "healthy", "timestamp": time.time()}

    try:
        # Test database
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM users")
            user_count = cursor.fetchone()[0]
            status["database"] = "healthy"
            status["user_count"] = user_count

        # Test bot status
        status["bot_connected"] = bot.is_ready()
        status["guilds_count"] = len(bot.guilds) if bot.guilds else 0

        # API status
        status["circuit_breaker"] = api_circuit_breaker.state.value
        status[
            "rate_limit_remaining"] = discord_rate_limiter.max_requests - len(
                discord_rate_limiter.requests)

        # Memory usage (optional - only if psutil is available)
        try:
            import psutil
            process = psutil.Process()
            status["memory_mb"] = round(
                process.memory_info().rss / 1024 / 1024, 1)
            status["cpu_percent"] = process.cpu_percent()
        except ImportError:
            status["memory_info"] = "psutil not available"

        return status, 200

    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e),
            "timestamp": time.time()
        }, 503


# ==== Discord Bot Setup ====
intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents, help_command=None)
last_gamble_times = {}


# ==== Background Task for Temp Admin Management ====
@tasks.loop(minutes=5)
async def remove_expired_items():
    """Remove expired temp admin roles and name changes"""
    # Handle temp admins
    temp_admins = get_temp_admins()
    now = datetime.datetime.now(timezone.utc)

    for admin_data in temp_admins:
        expire_time = datetime.datetime.fromisoformat(admin_data["expires_at"])
        if now >= expire_time:
            try:
                guild = bot.get_guild(int(admin_data["guild_id"]))
                if guild:
                    member = guild.get_member(int(admin_data["user_id"]))
                    role = guild.get_role(ROLE_ID_TEMP_ADMIN)
                    if member and role:
                        result, error = await safe_remove_roles(member, role)
                remove_temp_admin(admin_data["user_id"])
            except Exception as e:
                logger.error(f"Error removing temp admin role: {e}")

    # Handle name changes
    active_name_changes = get_active_name_changes()

    for change in active_name_changes:
        expire_time = datetime.datetime.fromisoformat(change["expires_at"])
        if now >= expire_time:
            try:
                guild = bot.get_guild(int(change["guild_id"]))
                if guild:
                    member = guild.get_member(int(change["target_id"]))
                    if member:
                        original_nick = change["original_nickname"]
                        if original_nick == "None":
                            original_nick = None
                        await member.edit(nick=original_nick,
                                          reason="Name change card expired")

                remove_name_change_card(change["id"])
                logger.info(
                    f"‚úÖ Name change expired for user {change['target_id']}")

            except Exception as e:
                logger.error(f"‚ùå Error restoring nickname: {e}")