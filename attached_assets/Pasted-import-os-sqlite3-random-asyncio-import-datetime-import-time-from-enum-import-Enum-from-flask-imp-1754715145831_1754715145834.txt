import os, sqlite3, random, asyncio
import datetime
import time
from enum import Enum
from flask import Flask
import discord
from discord.ext import commands, tasks
from threading import Thread
from dotenv import load_dotenv
import base64
from typing import Optional
import json
import contextlib
import threading
from queue import Queue
from concurrent.futures import ThreadPoolExecutor
import signal
import sys
import aiohttp
import requests
import shutil
from datetime import timezone, timedelta
import logging
from collections import defaultdict
from collections import deque
import functools
from functools import lru_cache  # This should already be there, but verify it exists

DB_LOCK = threading.Lock()
DB_POOL = ThreadPoolExecutor(max_workers=3)


@contextlib.contextmanager
def get_db_connection():
    with db_pool.get_connection() as conn:
        yield conn


class DatabasePool:

    def __init__(self, db_file, max_connections=5):
        self.db_file = db_file
        self.max_connections = max_connections
        self._pool = Queue(maxsize=max_connections)
        self._lock = threading.Lock()
        self._initialized = False

    def _initialize_pool(self):
        if not self._initialized:
            with self._lock:
                if not self._initialized:
                    for _ in range(self.max_connections):
                        conn = sqlite3.connect(self.db_file,
                                               timeout=30,
                                               check_same_thread=False)
                        conn.execute("PRAGMA journal_mode=WAL")
                        conn.execute("PRAGMA foreign_keys=ON")
                        self._pool.put(conn)
                    self._initialized = True

    @contextlib.contextmanager
    def get_connection(self):
        self._initialize_pool()
        conn = self._pool.get(timeout=10)
        try:
            yield conn
        except sqlite3.Error as e:
            logger.error(f"‚ùå Database error: {e}")
            conn.rollback()
            raise
        finally:
            self._pool.put(conn)


# Initialize pool
DB_FILE = "bot_database.db"
db_pool = DatabasePool(DB_FILE)

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Initialize placeholder variables (will be properly set later)
bot = None
github_backup = None

def signal_handler(signum, frame):
    """Handle shutdown signals gracefully"""
    signal_name = "SIGTERM" if signum == 15 else "SIGINT" if signum == 2 else f"Signal {signum}"
    logger.info(f"üõë Shutdown signal received: {signal_name}")

    # For hosting platforms, we want to shut down gracefully
    if bot and not bot.is_closed():
        logger.info("üîÑ Initiating graceful bot shutdown...")
        try:
            # Try to create a final backup
            backup_file = create_backup_with_cloud_storage()
            if backup_file and github_backup:
                success, result = github_backup.upload_backup_to_github(
                    backup_file)
                if success:
                    logger.info("‚úÖ Emergency backup created before shutdown")
        except Exception as e:
            logger.error(f"‚ùå Emergency backup failed: {e}")

        # Close the bot
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                loop.create_task(bot.close())
        except Exception as e:
            logger.exception(f"An unexpected error occurred: {e}")
            pass

    logger.info("üõë Bot shutdown complete")
    sys.exit(0)


class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"


class AsyncCircuitBreaker:

    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = 0
        self.state = CircuitState.CLOSED
        self._lock = asyncio.Lock()

    async def call(self, func, *args, **kwargs):
        async with self._lock:
            now = time.time()

            if self.state == CircuitState.OPEN:
                if now - self.last_failure_time > self.timeout:
                    self.state = CircuitState.HALF_OPEN
                    logger.info("üîÑ Circuit breaker transitioning to HALF_OPEN")
                else:
                    raise Exception(
                        "Circuit breaker is OPEN - rejecting request")

        try:
            # Call the async function properly
            if asyncio.iscoroutinefunction(func):
                result = await func(*args, **kwargs)
            else:
                result = func(*args, **kwargs)

            await self._on_success()
            return result
        except Exception as e:
            logger.exception(f"An unexpected error occurred: {e}")
            await self._on_failure()
            raise

    async def _on_success(self):
        async with self._lock:
            self.failure_count = 0
            if self.state == CircuitState.HALF_OPEN:
                self.state = CircuitState.CLOSED
                logger.info("‚úÖ Circuit breaker CLOSED - service recovered")

    async def _on_failure(self):
        async with self._lock:
            self.failure_count += 1
            self.last_failure_time = time.time()
            if self.failure_count >= self.failure_threshold:
                self.state = CircuitState.OPEN
                logger.error("üî¥ Circuit breaker OPEN - service failing")


# Update the global circuit breaker
api_circuit_breaker = AsyncCircuitBreaker(failure_threshold=3, timeout=120)


class TimedCache:

    def __init__(self, ttl_seconds=300):  # 5 minute TTL
        self.cache = {}
        self.ttl = ttl_seconds

    def get(self, key):
        if key in self.cache:
            value, timestamp = self.cache[key]
            if time.time() - timestamp < self.ttl:
                return value
            else:
                del self.cache[key]
        return None

    def set(self, key, value):
        self.cache[key] = (value, time.time())

    def clear(self):
        self.cache.clear()


# Create cache instances
user_cache = TimedCache(ttl_seconds=60)  # Cache user data for 1 minute
leaderboard_cache = TimedCache(ttl_seconds=300)
# Register signal handlers
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

# Rate limiting configuration
COMMAND_COOLDOWNS = {
    'daily': 86400,  # 24 hours
    'coinflip': 60,  # 1 minute
    'exchange': 10,  # 10 seconds
    'shop': 5,  # 5 seconds
    'buy': 30,  # 30 seconds
    'ssbal': 3,  # 3 seconds
    'spbal': 3,  # 3 seconds
    'top': 10,  # 10 seconds
    'lucky': 10,  # 10 seconds
    'unlucky': 10,  # 10 seconds
    'lose': 5,  # 5 seconds
    'help': 5,  # 5 seconds
    'sendsp': 5,  # ADD THIS - 5 seconds cooldown
    'nextconvert': 10,  # 10 seconds
}

# Global rate limiting storage
user_command_cooldowns = defaultdict(lambda: defaultdict(float))
global_command_usage = defaultdict(list)

# Discord API rate limiting
API_WINDOW = 60  # seconds
DISCORD_API_LIMIT = 45  # requests per window
discord_api_calls = []


class AdvancedRateLimit:

    def __init__(self, max_requests=45, window=60):  # More conservative
        self.max_requests = max_requests
        self.window = window
        self.requests = deque()
        self.lock = asyncio.Lock()

    async def acquire(self):
        async with self.lock:
            now = time.time()

            # Remove old requests
            while self.requests and self.requests[0] <= now - self.window:
                self.requests.popleft()

            # Check if we can make a request
            if len(self.requests) >= self.max_requests:
                sleep_time = self.window - (now - self.requests[0]) + 1
                logger.warning(
                    f"‚ö†Ô∏è Rate limit hit, sleeping {sleep_time:.1f}s")
                await asyncio.sleep(sleep_time)
                return await self.acquire()  # Recursive retry

            self.requests.append(now)
            return True


discord_rate_limiter = AdvancedRateLimit(max_requests=45, window=60)


def check_command_cooldown(user_id, command_name):
    """Check if user can use a command (returns True if allowed)"""
    if command_name not in COMMAND_COOLDOWNS:
        return True, 0

    now = time.time()
    last_used = user_command_cooldowns[str(user_id)][command_name]
    cooldown = COMMAND_COOLDOWNS[command_name]

    if now - last_used < cooldown:
        remaining = cooldown - (now - last_used)
        return False, remaining

    user_command_cooldowns[str(user_id)][command_name] = now
    return True, 0


# REPLACE enhanced_safe_api_call function:
async def enhanced_safe_api_call(func, *args, **kwargs):
    """Enhanced API call with circuit breaker and exponential backoff"""
    max_retries = 3
    base_delay = 1  # Reduced from 2

    for attempt in range(max_retries):
        try:
            # Acquire rate limit token first
            await discord_rate_limiter.acquire()

            # Use the async circuit breaker properly
            result = await api_circuit_breaker.call(func, *args, **kwargs)
            return result, None

        except discord.HTTPException as e:
            if e.status == 429:
                # Get retry_after from Discord's response
                retry_after = getattr(e, 'retry_after',
                                      base_delay * (2**attempt))
                retry_after = min(retry_after, 60)  # Max 1 minute
                logger.warning(f"‚ö†Ô∏è Rate limited, waiting {retry_after:.1f}s")
                await asyncio.sleep(retry_after)
                continue
            elif e.status >= 500:
                delay = min(base_delay * (2**attempt), 30)
                logger.error(
                    f"‚ùå Discord server error {e.status}, waiting {delay}s")
                await asyncio.sleep(delay)
                continue
            else:
                return None, f"Discord API Error: {e.status}"

        except asyncio.TimeoutError:
            delay = min(base_delay * (2**attempt), 15)
            logger.warning(f"‚ö†Ô∏è Timeout, retrying in {delay}s")
            await asyncio.sleep(delay)
            continue

        except Exception as e:
            logger.error(f"‚ùå API call error: {e}")
            if attempt == max_retries - 1:
                return None, str(e)
            await asyncio.sleep(base_delay * (2**attempt))

    return None, "Max retries exceeded"


async def safe_api_call(func, *args, **kwargs):
    """Simple wrapper for the enhanced API call function"""
    # Track API calls for monitoring
    discord_api_calls.append(time.time())
    result, error = await enhanced_safe_api_call(func, *args, **kwargs)
    return result, error


# Command cooldown decorator
def cooldown_check(command_name=None):
    """Decorator to add cooldown checking to commands"""

    def decorator(func):

        @functools.wraps(func)
        async def cooldown_wrapper(ctx, *args, **kwargs):
            cmd_name = command_name or func.__name__
            user_id = ctx.author.id

            can_use, remaining = check_command_cooldown(user_id, cmd_name)

            if not can_use:
                hours = int(remaining // 3600)
                minutes = int((remaining % 3600) // 60)
                seconds = int(remaining % 60)

                if hours > 0:
                    time_str = f"{hours}h {minutes}m {seconds}s"
                elif minutes > 0:
                    time_str = f"{minutes}m {seconds}s"
                else:
                    time_str = f"{seconds}s"

                embed = discord.Embed(
                    title="‚è∞ **COMMAND COOLDOWN**",
                    description=
                    f"```diff\n- Command '{cmd_name}' is on cooldown\n+ Try again in {time_str}\n```\nüåÄ *The cosmic forces need time to recharge...*",
                    color=0xFF6347)

                embed.set_footer(
                    text=
                    f"‚ö° Cooldown prevents API overload ‚Ä¢ {ctx.author.display_name}",
                    icon_url=ctx.author.avatar.url
                    if ctx.author.avatar else None)

                result, error = await safe_api_call(ctx.send, embed=embed)
                if error:
                    logger.error(f"‚ùå Failed to send cooldown message: {error}")
                return

            # Execute the original command
            try:
                await func(ctx, *args, **kwargs)
            except Exception as e:
                logger.error(f"‚ùå Error in command {cmd_name}: {e}")

                embed = discord.Embed(
                    title="‚ùå **COMMAND ERROR**",
                    description=
                    "```diff\n- An error occurred while processing your command\n+ Please try again later\n```",
                    color=0xFF0000)

                result, error = await safe_api_call(ctx.send, embed=embed)
                if error:
                    logger.error(f"‚ùå Failed to send error message: {error}")

        return cooldown_wrapper

    return decorator


def safe_command_wrapper(func):
    """Decorator to add extra error protection to critical commands"""

    @functools.wraps(func)
    async def wrapper(ctx, *args, **kwargs):
        try:
            await func(ctx, *args, **kwargs)
        except Exception as e:
            logger.error(f"‚ùå Critical error in {func.__name__}: {e}",
                         exc_info=True)

            # Send a simple error message without fancy embeds
            try:
                await ctx.send(
                    "‚ùå An unexpected error occurred. The issue has been logged."
                )
            except discord.DiscordException as e:
                logger.error(
                    f"‚ùå Could not send error message to user {ctx.author.id}: {e}"
                )
                pass  # If we can't even send a simple message, just log it

    return wrapper


# Enhanced message sending with rate limiting
async def safe_send(ctx, content=None, embed=None, **kwargs):
    """Safely send messages with rate limiting"""
    return await safe_api_call(ctx.send,
                               content=content,
                               embed=embed,
                               **kwargs)


async def safe_edit(message, content=None, embed=None, **kwargs):
    """Safely edit messages with rate limiting"""
    return await safe_api_call(message.edit,
                               content=content,
                               embed=embed,
                               **kwargs)


async def safe_add_reaction(message, emoji):
    """Safely add reactions with rate limiting"""
    return await safe_api_call(message.add_reaction, emoji)


async def safe_remove_roles(member, *roles):
    """Safely remove roles with rate limiting"""
    return await safe_api_call(member.remove_roles, *roles)


async def safe_add_roles(member, *roles):
    """Safely add roles with rate limiting"""
    return await safe_api_call(member.add_roles, *roles)


# Global error handler for uncaught exceptions
async def handle_global_error(ctx, error):
    """Handle global command errors with fallback protection"""
    logger.error(f"‚ùå Global error in {ctx.command}: {error}")

    if isinstance(error, commands.CommandOnCooldown):
        return  # Already handled by cooldown system

    try:
        embed = discord.Embed(
            title="üí• **SYSTEM ERROR**",
            description=
            "```diff\n- A system error occurred\n+ Our cosmic engineers have been notified\n```\nüîß *Please try again in a few moments...*",
            color=0xFF1744)

        embed.add_field(name="üÜò **Error Code**",
                        value=f"```\n{type(error).__name__}\n```",
                        inline=True)

        embed.set_footer(
            text="üõ†Ô∏è If this persists, contact an administrator",
            icon_url=ctx.author.avatar.url if ctx.author.avatar else None)

        # Use a simple send without the safe_send wrapper to prevent recursion
        try:
            await ctx.send(embed=embed)
        except Exception as embed_send_error:
            # Fallback: try sending a simple text message
            logger.error(f"‚ùå Error sending embed: {embed_send_error}")
            try:
                await ctx.send(
                    "‚ùå A system error occurred. Please contact an administrator."
                )
            except discord.DiscordException as text_send_error:
                # Ultimate fallback: just log it
                logger.error(
                    f"‚ùå Could not send error message to user {ctx.author.id}: {text_send_error}"
                )
                pass

    except Exception as handler_error:
        # Don't let the error handler itself crash the bot
        logger.error(f"‚ùå Error in global error handler: {handler_error}")


load_dotenv()
TOKEN = os.getenv("DISCORD_BOT_TOKEN")

# ==== Constants ====
DB_FILE = "bot_database.db"
ROLE_ID_TEMP_ADMIN = 1393927331101544539  # Replace with actual ID
ROLE_ID_HMW = 1393927051685400790  # Replace with actual HMW role ID
ROLE_ID_ADMIN = 1397799884790169771  # Replace with actual Admin role ID
ROLE_ID_BOOSTER = 1393289422241271940  # Replace with actual Server Booster role ID
ROLE_ID_OWNER = 1393074903716073582
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
GITHUB_BACKUP_REPO = os.getenv(
    "GITHUB_BACKUP_REPO")  # Format: "username/repo-name"
GITHUB_API_BASE = "https://api.github.com"

SHOP_ITEMS = {
    "nickname_lock": {
        "price": 5000,
        "desc": "üîí Locks your nickname from changes"
    },
    "temp_admin": {
        "price": 25000,
        "desc": "‚ö° Gives temporary admin role for 1 hour"
    },
    "hmw_role": {
        "price": 50000,
        "desc": "üëë Grants the prestigious HMW role"
    },
    "name_change_card": {  # ADD THIS NEW ITEM
        "price": 10000,
        "desc": "üÉè Change someone's nickname for 24 hours"
    },
}


# ==== Database Setup ====
def init_database():
    """Initialize SQLite database with all required tables"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Users table for economy data
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id TEXT PRIMARY KEY,
            balance INTEGER DEFAULT 0,
            sp INTEGER DEFAULT 100,
            last_claim TEXT,
            streak INTEGER DEFAULT 0,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')

    # Monthly stats table for gambling tracking
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS monthly_stats (
            user_id TEXT,
            month TEXT,
            wins INTEGER DEFAULT 0,
            losses INTEGER DEFAULT 0,
            PRIMARY KEY (user_id, month),
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )
    ''')

    # Nickname locks table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS nickname_locks (
            user_id TEXT PRIMARY KEY,
            locked_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')

    # Temporary admins table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS temp_admins (
            user_id TEXT PRIMARY KEY,
            expires_at TEXT,
            guild_id TEXT,
            granted_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')

    # Add this table creation in init_database() function
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS name_change_cards (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            owner_id TEXT,
            target_id TEXT,
            original_nickname TEXT,
            new_nickname TEXT,
            expires_at TEXT,
            guild_id TEXT,
            used_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')

    # Transactions log for audit trail
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS transactions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT,
            transaction_type TEXT,
            amount INTEGER,
            balance_before INTEGER,
            balance_after INTEGER,
            description TEXT,
            timestamp TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')

    cursor.execute(
        'CREATE INDEX IF NOT EXISTS idx_users_balance ON users(balance DESC)')
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_users_sp ON users(sp DESC)')
    cursor.execute(
        'CREATE INDEX IF NOT EXISTS idx_monthly_stats_month ON monthly_stats(month)'
    )
    cursor.execute(
        'CREATE INDEX IF NOT EXISTS idx_monthly_stats_losses ON monthly_stats(losses DESC)'
    )
    cursor.execute(
        'CREATE INDEX IF NOT EXISTS idx_temp_admins_expires ON temp_admins(expires_at)'
    )
    cursor.execute(
        'CREATE INDEX IF NOT EXISTS idx_name_change_cards_expires ON name_change_cards(expires_at)'
    )
    cursor.execute(
        'CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id)'
    )
    cursor.execute(
        'CREATE INDEX IF NOT EXISTS idx_transactions_timestamp ON transactions(timestamp DESC)'
    )

    conn.commit()
    conn.close()


# ==== Database Helper Functions ====
def get_user_data(user_id):
    """Enhanced get user data with proper error handling"""
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM users WHERE user_id = ?',
                           (user_id, ))
            user = cursor.fetchone()

            if not user:
                cursor.execute(
                    '''
                    INSERT INTO users (user_id, balance, sp, streak)
                    VALUES (?, 0, 100, 0)
                ''', (user_id, ))
                conn.commit()
                cursor.execute('SELECT * FROM users WHERE user_id = ?',
                               (user_id, ))
                user = cursor.fetchone()

            return {
                'user_id': user[0],
                'balance': user[1],
                'sp': user[2],
                'last_claim': user[3],
                'streak': user[4],
                'created_at': user[5]
            }
    except Exception as e:
        logger.error(f"‚ùå get_user_data error: {e}")
        # Return default data on error
        return {
            'user_id': user_id,
            'balance': 0,
            'sp': 100,
            'last_claim': None,
            'streak': 0,
            'created_at': None
        }


async def _safe_update_user_data(user_id, **kwargs):
    """Helper function to perform the actual database update (async)"""
    # Validate allowed fields to prevent injection
    ALLOWED_FIELDS = {'balance', 'sp', 'last_claim', 'streak'}

    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()

            # Ensure user exists first
            cursor.execute('SELECT user_id FROM users WHERE user_id = ?',
                           (user_id, ))
            if not cursor.fetchone():
                cursor.execute(
                    'INSERT INTO users (user_id, balance, sp, streak) VALUES (?, 0, 100, 0)',
                    (user_id, ))

            # Build update query with validated fields only
            valid_updates = {
                k: v
                for k, v in kwargs.items() if k in ALLOWED_FIELDS
            }

            if valid_updates:
                placeholders = ', '.join(f'{field} = ?'
                                         for field in valid_updates.keys())
                query = f'UPDATE users SET {placeholders} WHERE user_id = ?'
                values = list(valid_updates.values()) + [user_id]
                cursor.execute(query, values)

            conn.commit()
            return True

    except sqlite3.OperationalError as e:
        logger.error(f"‚ùå Database error: {e}")
        return False
    except Exception as e:
        logger.error(f"‚ùå Update error: {e}")
        return False


async def safe_update_user_data(user_id, **kwargs):
    """Thread-safe user data update with retry logic (async wrapper)"""
    max_retries = 3
    retry_delay = 0.5

    for attempt in range(max_retries):
        try:
            result = await _safe_update_user_data(user_id, **kwargs)
            if result:
                return True
            else:
                if attempt < max_retries - 1:
                    await asyncio.sleep(retry_delay * (2**attempt))
                    continue
                else:
                    return False

        except Exception as e:
            logger.error(f"‚ùå Error during retry: {e}")
            return False

    return False


def update_user_data(user_id, **kwargs):
    """Wrapper for safe_update_user_data to maintain compatibility"""
    return asyncio.run(safe_update_user_data(user_id, **kwargs))


def get_monthly_stats(user_id, month=None):
    """Get monthly gambling stats for user"""
    if not month:
        month = datetime.datetime.now(timezone.utc).strftime("%Y-%m")

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute(
        '''
        SELECT wins, losses FROM monthly_stats 
        WHERE user_id = ? AND month = ?
    ''', (user_id, month))

    result = cursor.fetchone()
    conn.close()

    if result:
        return {'wins': result[0], 'losses': result[1]}
    return {'wins': 0, 'losses': 0}


async def test_bot_connection():
    """Test bot connection before full startup"""
    try:
        async with aiohttp.ClientSession() as session:
            headers = {"Authorization": f"Bot {TOKEN}"}
            async with session.get("https://discord.com/api/v10/users/@me",
                                   headers=headers) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    logger.info(
                        f"‚úÖ Bot token valid for: {data.get('username')}")
                    return True
                else:
                    logger.error(f"‚ùå Invalid bot token: {resp.status}")
                    return False
    except Exception as e:
        logger.error(f"‚ùå Connection test failed: {e}")
        return False


async def startup_backup():
    """Create backup on startup"""
    try:
        if github_backup and os.path.exists(DB_FILE):
            backup_file = create_backup_with_cloud_storage()
            if backup_file:
                success, result = github_backup.upload_backup_to_github(
                    backup_file)
                if success:
                    logger.info("‚úÖ Startup backup created")
                    return True
        return False
    except Exception as e:
        logger.error(f"‚ùå Startup backup failed: {e}")
        return False


def update_monthly_stats(user_id, win_amount=0, loss_amount=0, month=None):
    """Update monthly gambling stats"""
    if not month:
        month = datetime.datetime.now(timezone.utc).strftime("%Y-%m")

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute(
        '''
        INSERT OR REPLACE INTO monthly_stats (user_id, month, wins, losses)
        VALUES (?, ?, 
            COALESCE((SELECT wins FROM monthly_stats WHERE user_id = ? AND month = ?), 0) + ?,
            COALESCE((SELECT losses FROM monthly_stats WHERE user_id = ? AND month = ?), 0) + ?)
    ''', (user_id, month, user_id, month, win_amount, user_id, month,
          loss_amount))

    conn.commit()
    conn.close()


class GitHubBackupManager:

    def __init__(self, token, repo):
        self.token = token
        self.repo = repo
        self.headers = {
            "Authorization": f"token {token}",
            "Accept": "application/vnd.github.v3+json",
            "Content-Type": "application/json"
        }

    def upload_backup_to_github(self, backup_file_path):
        """Upload backup file to GitHub repository"""
        try:
            # Read the backup file
            with open(backup_file_path, 'rb') as f:
                file_content = f.read()

            # Encode file content to base64
            encoded_content = base64.b64encode(file_content).decode('utf-8')

            # Create filename for GitHub
            filename = os.path.basename(backup_file_path)
            github_path = f"backups/{filename}"

            # Check if file already exists
            check_url = f"{GITHUB_API_BASE}/repos/{self.repo}/contents/{github_path}"
            check_response = requests.get(check_url, headers=self.headers)

            # Prepare the commit data
            commit_data = {
                "message": f"ü§ñ Auto backup: {filename}",
                "content": encoded_content,
                "branch": "main"
            }

            # If file exists, we need the SHA for update
            if check_response.status_code == 200:
                existing_file = check_response.json()
                commit_data["sha"] = existing_file["sha"]

            # Upload/update the file
            upload_url = f"{GITHUB_API_BASE}/repos/{self.repo}/contents/{github_path}"
            response = requests.put(upload_url,
                                    headers=self.headers,
                                    json=commit_data)

            if response.status_code in [200, 201]:
                return True, response.json()
            else:
                return False, f"GitHub API Error: {response.status_code} - {response.text}"

        except Exception as e:
            return False, str(e)

    def download_backup_from_github(self, filename=None):
        """Download backup file from GitHub repository"""
        try:
            if not filename:
                # Get the latest backup file
                list_url = f"{GITHUB_API_BASE}/repos/{self.repo}/contents/backups"
                response = requests.get(list_url, headers=self.headers)

                if response.status_code != 200:
                    return False, "Failed to list backup files"

                files = response.json()
                backup_files = [f for f in files if f['name'].endswith('.db')]

                if not backup_files:
                    return False, "No backup files found in repository"

                # Sort by name (which includes timestamp) to get latest
                backup_files.sort(key=lambda x: x['name'], reverse=True)
                latest_file = backup_files[0]
                filename = latest_file['name']

            # Download the specific file
            download_url = f"{GITHUB_API_BASE}/repos/{self.repo}/contents/backups/{filename}"
            response = requests.get(download_url, headers=self.headers)

            if response.status_code != 200:
                return False, f"Failed to download {filename}"

            file_data = response.json()

            # Decode base64 content
            file_content = base64.b64decode(file_data['content'])

            # Create local backups directory if it doesn't exist
            if not os.path.exists("backups"):
                os.makedirs("backups")

            # Save the downloaded file locally
            local_path = os.path.join("backups", filename)
            with open(local_path, 'wb') as f:
                f.write(file_content)

            return True, local_path

        except Exception as e:
            return False, str(e)

    def list_github_backups(self):
        """List all backup files in GitHub repository"""
        try:
            list_url = f"{GITHUB_API_BASE}/repos/{self.repo}/contents/backups"
            response = requests.get(list_url, headers=self.headers)

            if response.status_code != 200:
                return False, []

            files = response.json()
            backup_files = [f for f in files if f['name'].endswith('.db')]

            # Sort by name (timestamp) in descending order
            backup_files.sort(key=lambda x: x['name'], reverse=True)

            return True, backup_files

        except Exception as e:
            logger.error(f"Error listing GitHub backups: {e}")
            return False, []


# Initialize GitHub backup manager (overwrite the None placeholder)
if GITHUB_TOKEN and GITHUB_BACKUP_REPO:
    github_backup = GitHubBackupManager(GITHUB_TOKEN, GITHUB_BACKUP_REPO)


def create_backup_with_cloud_storage():
    """Create a backup file and return the file path"""
    try:
        # Create backups directory if it doesn't exist
        if not os.path.exists("backups"):
            os.makedirs("backups")

        # Generate backup filename with timestamp
        timestamp = datetime.datetime.now(timezone.utc).strftime("%Y-%m")
        backup_filename = f"backup_{timestamp}.db"
        backup_path = os.path.join("backups", backup_filename)

        # Copy the database file
        shutil.copy2(DB_FILE, backup_path)

        return backup_path
    except Exception as e:
        print(f"Backup creation error: {e}")
        return None


def restore_from_cloud():
    """Restore database from the most recent backup (local or GitHub)"""
    try:
        latest_backup = None
        restored_from_github = False

        # Try to download latest from GitHub first
        if github_backup:
            success, result = github_backup.download_backup_from_github()
            if success:
                latest_backup = result
                restored_from_github = True
            else:
                print(f"GitHub download failed: {result}")

        # Fallback to local backups if GitHub fails
        if not restored_from_github:
            if not os.path.exists("backups"):
                logger.warning(
                    "‚ö†Ô∏è No backup found to restore from. Creating a new database."
                )
                init_database()
                return True

            backup_files = [
                f for f in os.listdir("backups")
                if f.startswith("backup_") and f.endswith(".db")
            ]
            if not backup_files:
                logger.warning(
                    "‚ö†Ô∏è No backup found to restore from. Creating a new database."
                )
                init_database()
                return True

            backup_files.sort(
                key=lambda x: os.path.getmtime(os.path.join("backups", x)),
                reverse=True)
            latest_backup = os.path.join("backups", backup_files[0])

        # Only proceed if we have a backup to restore
        if latest_backup:
            # Backup current database before restore
            current_backup = f"pre_restore_backup_{datetime.datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.db"
            shutil.copy2(DB_FILE, os.path.join("backups", current_backup))

            # Restore from backup
            shutil.copy2(latest_backup, DB_FILE)
            logger.info(f"‚úÖ Database restored from: {latest_backup}")
            return True
        else:
            logger.warning(
                "‚ö†Ô∏è No backup found to restore from. Creating a new database.")
            init_database()
            return True

    except Exception as e:
        logger.error(f"‚ùå Database restore failed: {e}")
        return False


def log_transaction(user_id,
                    transaction_type,
                    amount,
                    balance_before,
                    balance_after,
                    description=""):
    """Log transaction for audit trail"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute(
        '''
        INSERT INTO transactions (user_id, transaction_type, amount, balance_before, balance_after, description)
        VALUES (?, ?, ?, ?, ?, ?)
    ''', (user_id, transaction_type, amount, balance_before, balance_after,
          description))

    conn.commit()
    conn.close()


def is_nickname_locked(user_id):
    """Check if user has nickname lock"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute('SELECT user_id FROM nickname_locks WHERE user_id = ?',
                   (user_id, ))
    result = cursor.fetchone()
    conn.close()

    return result is not None


def add_name_change_card(owner_id, target_id, original_nick, new_nick,
                         expires_at, guild_id):
    """Add a name change card record"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute(
        '''
        INSERT INTO name_change_cards (owner_id, target_id, original_nickname, new_nickname, expires_at, guild_id)
        VALUES (?, ?, ?, ?, ?, ?)
    ''', (owner_id, target_id, original_nick, new_nick, expires_at, guild_id))

    conn.commit()
    conn.close()


def get_active_name_changes():
    """Get all active name changes"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute('''
        SELECT id, owner_id, target_id, original_nickname, expires_at, guild_id 
        FROM name_change_cards
    ''')
    results = cursor.fetchall()
    conn.close()

    return [{
        'id': r[0],
        'owner_id': r[1],
        'target_id': r[2],
        'original_nickname': r[3],
        'expires_at': r[4],
        'guild_id': r[5]
    } for r in results]


def remove_name_change_card(card_id):
    """Remove a name change card record"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute('DELETE FROM name_change_cards WHERE id = ?', (card_id, ))
    conn.commit()
    conn.close()


def add_nickname_lock(user_id):
    """Add nickname lock for user"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute(
        'INSERT OR REPLACE INTO nickname_locks (user_id) VALUES (?)',
        (user_id, ))
    conn.commit()
    conn.close()


def get_temp_admins():
    """Get all temp admins"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute('SELECT user_id, expires_at, guild_id FROM temp_admins')
    results = cursor.fetchall()
    conn.close()

    return [{
        'user_id': r[0],
        'expires_at': r[1],
        'guild_id': r[2]
    } for r in results]


def add_temp_admin(user_id, expires_at, guild_id):
    """Add temporary admin"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute(
        '''
        INSERT OR REPLACE INTO temp_admins (user_id, expires_at, guild_id)
        VALUES (?, ?, ?)
    ''', (user_id, expires_at, guild_id))

    conn.commit()
    conn.close()


def remove_temp_admin(user_id):
    """Remove temporary admin"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute('DELETE FROM temp_admins WHERE user_id = ?', (user_id, ))
    conn.commit()
    conn.close()


def get_leaderboard(field='balance', limit=10):
    """Get leaderboard by specified field"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    query = f'SELECT user_id, {field} FROM users ORDER BY {field} DESC LIMIT ?'
    cursor.execute(query, (limit, ))
    results = cursor.fetchall()
    conn.close()

    return results


def get_top_losers(month=None, limit=10):
    """Get top losers for the month"""
    if not month:
        month = datetime.datetime.now(timezone.utc).strftime("%Y-%m")

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute(
        '''
        SELECT user_id, losses FROM monthly_stats 
        WHERE month = ? ORDER BY losses DESC LIMIT ?
    ''', (month, limit))

    results = cursor.fetchall()
    conn.close()

    return results


# Initialize database on startup
def ensure_database_exists():
    """Ensure database exists, restore from backup if needed"""
    if not os.path.exists(DB_FILE):
        logger.warning("‚ö†Ô∏è Database not found, attempting restore...")
        if github_backup and restore_from_cloud():
            logger.info("‚úÖ Database restored from backup")
        else:
            logger.info("üìù Creating new database...")
            init_database()
    else:
        init_database()  # Ensure all tables exist


# Initialize database on startup
ensure_database_exists()


async def enhanced_startup():
    """Enhanced startup with health checks and graceful degradation"""
    logger.info("üöÄ Enhanced startup sequence beginning...")

    # Test database first
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM users")
            logger.info("‚úÖ Database connection verified")
    except Exception as e:
        logger.error(f"‚ùå Database startup failed: {e}")
        return False

    # Test Discord API
    try:
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(
                total=10)) as session:
            headers = {"Authorization": f"Bot {TOKEN}"}
            async with session.get("https://discord.com/api/v10/users/@me",
                                   headers=headers) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    logger.info(
                        f"‚úÖ Discord API connection verified: {data.get('username')}"
                    )
                else:
                    logger.error(f"‚ùå Discord API error: {resp.status}")
                    return False
    except Exception as e:
        logger.error(f"‚ùå Discord API test failed: {e}")
        return False

    # Initialize circuit breaker
    api_circuit_breaker.state = CircuitState.CLOSED
    logger.info("‚úÖ Circuit breaker initialized")

    return True


# ==== Input Validation ====
def validate_amount(amount_str, max_amount=1000000):
    """Validate and convert amount string to integer"""
    if amount_str.lower() == "all":
        return "all"
    try:
        amount = int(amount_str)
        if amount <= 0:
            return None
        if amount > max_amount:
            return None
        return amount
    except ValueError:
        return None


# ==== Auto Backup Task ====
@tasks.loop(hours=6)  # Backup every 6 hours
async def auto_backup():
    """Automatically backup database to GitHub"""
    try:
        if github_backup:
            backup_file = create_backup_with_cloud_storage()
            if backup_file:
                success, result = github_backup.upload_backup_to_github(
                    backup_file)
                if success:
                    logger.info(f"‚úÖ Auto backup completed: {backup_file}")
                else:
                    logger.error(f"‚ùå Auto backup failed: {result}")
    except Exception as e:
        logger.error(f"‚ùå Auto backup error: {e}")


# ==== Monthly Conversion System ====


def get_all_users_with_sp():
    """Get all users who have SP > 0"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    cursor.execute('SELECT user_id, sp, balance FROM users WHERE sp > 0')
    results = cursor.fetchall()
    conn.close()

    return [{'user_id': r[0], 'sp': r[1], 'balance': r[2]} for r in results]


def reset_monthly_stats():
    """Reset monthly gambling stats for new month"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Clear previous month's stats (keep only current month)
    current_month = datetime.datetime.now(timezone.utc).strftime("%Y-%m")
    cursor.execute('DELETE FROM monthly_stats WHERE month != ?',
                   (current_month, ))

    conn.commit()
    conn.close()


async def perform_monthly_conversion():
    """Convert all SP to SS for all users and reset SP"""
    try:
        users_with_sp = get_all_users_with_sp()
        total_converted = 0
        conversion_count = 0

        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        for user_data in users_with_sp:
            user_id = user_data['user_id']
            sp_amount = user_data['sp']
            old_balance = user_data['balance']

            if sp_amount > 0:
                # Convert SP to SS
                new_balance = old_balance + sp_amount
                new_sp = 100  # Reset to starting SP amount

                # Update database
                cursor.execute(
                    '''
                    UPDATE users SET balance = ?, sp = ? WHERE user_id = ?
                ''', (new_balance, new_sp, user_id))

                # Log transaction
                log_transaction(
                    user_id, "monthly_conversion", sp_amount, old_balance,
                    new_balance,
                    f"Monthly auto-conversion: {sp_amount} SP ‚Üí SS")

                total_converted += sp_amount
                conversion_count += 1

                logger.info(
                    f"‚úÖ Converted {sp_amount} SP ‚Üí SS for user {user_id}")

        conn.commit()
        conn.close()

        # Reset monthly gambling stats
        reset_monthly_stats()

        logger.info(
            f"üéØ Monthly conversion complete: {conversion_count} users, {total_converted:,} SP converted"
        )
        return total_converted, conversion_count

    except Exception as e:
        logger.error(f"‚ùå Monthly conversion error: {e}")
        return 0, 0


@tasks.loop(hours=1)  # Check every hour
async def monthly_conversion_check():
    """Check if it's time for monthly conversion (1st of month, 00:00 UTC)"""
    try:
        now = datetime.datetime.now(timezone.utc)

        # Check if it's the 1st day of the month and between 00:00-01:00
        if now.day == 1 and now.hour == 0:
            logger.info("üóìÔ∏è Monthly conversion time detected!")

            total_converted, user_count = await perform_monthly_conversion()

            if total_converted > 0:
                # Create backup after monthly conversion
                if github_backup:
                    backup_file = create_backup_with_cloud_storage()
                    if backup_file:
                        success, result = github_backup.upload_backup_to_github(
                            backup_file)
                        if success:
                            logger.info("‚úÖ Post-conversion backup created")

                # Notify in all guilds (optional)
                for guild in bot.guilds:
                    # Find a general channel to announce - ensure it's a TextChannel
                    channel = discord.utils.get(guild.text_channels,
                                                name='general')
                    if not channel and guild.text_channels:
                        channel = guild.text_channels[0]

                    if channel and isinstance(channel, discord.TextChannel):
                        try:
                            embed = discord.Embed(
                                title="üåü **MONTHLY ASCENSION COMPLETE** üåü",
                                description=
                                "```css\n[SPIRIT ENERGY CRYSTALLIZATION RITUAL]\n```\nüíé *The cosmic cycle renews, power has been preserved...*",
                                color=0x00FF7F)

                            embed.add_field(
                                name="‚öóÔ∏è **CONVERSION RESULTS**",
                                value=
                                f"```yaml\nUsers Affected: {user_count:,}\nTotal SP Converted: {total_converted:,}\nConversion Rate: 1 SP = 1 SS\n```",
                                inline=False)

                            embed.add_field(
                                name="üîÑ **WHAT HAPPENED?**",
                                value=
                                "```diff\n+ All Spirit Points ‚Üí Spirit Stones\n+ SP reset to 100 for everyone\n+ Monthly gambling stats reset\n+ Your wealth is now permanent!\n```",
                                inline=False)

                            embed.add_field(
                                name="üöÄ **NEW MONTH BEGINS**",
                                value=
                                "```fix\nFresh start for daily claims and gambling!\nYour converted SS is safe forever.\nTime to build your SP again!\n```",
                                inline=False)

                            embed.set_footer(
                                text=
                                f"üí´ Monthly Conversion ‚Ä¢ {now.strftime('%B %Y')}",
                                icon_url=guild.icon.url
                                if guild.icon else None)

                            await channel.send(embed=embed)
                            logger.info(
                                f"üì¢ Monthly conversion announced in {guild.name}"
                            )

                        except Exception as e:
                            logger.error(
                                f"‚ùå Failed to announce in {guild.name}: {e}")
                    else:
                        logger.warning(
                            f"‚ùå No suitable text channel found in {guild.name}"
                        )

    except Exception as e:
        logger.error(f"‚ùå Monthly conversion check error: {e}")


# AP I Health monitoring
@tasks.loop(minutes=5)
async def api_health_monitor():
    """Monitor API usage and rate limiting status"""
    try:
        now = time.time()

        # Clean old API call records
        global discord_api_calls
        discord_api_calls = [
            call_time for call_time in discord_api_calls
            if now - call_time < API_WINDOW
        ]

        # IMPROVED CLEANUP - Add size limits
        for user_id in list(user_command_cooldowns.keys()):
            user_commands = user_command_cooldowns[user_id]

            # Remove expired cooldowns
            for command in list(user_commands.keys()):
                if now - user_commands[command] > 86400:  # 24 hours
                    del user_commands[command]

            # Remove empty user records
            if not user_commands:
                del user_command_cooldowns[user_id]

        # CRITICAL: Prevent memory explosion - limit total entries
        if len(user_command_cooldowns) > 10000:  # Safety limit
            logger.warning(
                "‚ö†Ô∏è Cooldown dictionary too large, clearing old entries")
            # Keep only the 1000 most recent entries
            sorted_users = sorted(user_command_cooldowns.items(),
                                  key=lambda x: max(x[1].values())
                                  if x[1] else 0,
                                  reverse=True)
            user_command_cooldowns.clear()
            user_command_cooldowns.update(dict(sorted_users[:1000]))

    except Exception as e:
        logger.error(f"‚ùå API health monitor error: {e}")


async def main():
    """Main async function with proper startup sequence and error recovery"""
    logger.info("üöÄ Starting Discord Bot...")

    # Check if TOKEN is valid before proceeding
    if not TOKEN:
        logger.critical("‚ùå DISCORD_BOT_TOKEN not set in environment variables")
        logger.critical(
            "Please set your Discord bot token in the environment variables")
        return

    max_connection_retries = 5
    retry_delay = 10  # seconds

    for attempt in range(max_connection_retries):
        try:
            # Test connection first
            logger.info(
                f"üîç Testing connection (attempt {attempt + 1}/{max_connection_retries})..."
            )
            if not await test_bot_connection():
                logger.error("‚ùå Bot token validation failed")
                if attempt < max_connection_retries - 1:
                    logger.info(f"‚è≥ Retrying in {retry_delay} seconds...")
                    await asyncio.sleep(retry_delay)
                    continue
                else:
                    return

            # Create startup backup
            await startup_backup()

            # Start the bot
            logger.info("ü§ñ Starting Discord bot connection...")
            await bot.start(TOKEN)
            break  # If we get here, bot started successfully

        except discord.LoginFailure:
            logger.error("‚ùå Invalid bot token")
            break

        except discord.HTTPException as e:
            logger.error(f"‚ùå Discord HTTP error: {e}")
            if attempt < max_connection_retries - 1:
                logger.info(f"‚è≥ Retrying in {retry_delay} seconds...")
                await asyncio.sleep(retry_delay)
                retry_delay *= 2  # Exponential backoff
            else:
                logger.error("‚ùå Max retries exceeded")

        except KeyboardInterrupt:
            logger.info("üõë Keyboard interrupt received")
            break

        except Exception as e:
            logger.error(f"‚ùå Unexpected bot error: {e}")
            if attempt < max_connection_retries - 1:
                logger.info(f"‚è≥ Retrying in {retry_delay} seconds...")
                await asyncio.sleep(retry_delay)
                retry_delay *= 2
            else:
                logger.error("‚ùå Max retries exceeded")

    # Cleanup
    try:
        if not bot.is_closed():
            logger.info("üõë Closing bot connection...")
            await bot.close()
    except Exception as e:
        logger.error(f"‚ùå Error during cleanup: {e}")

    logger.info("üõë Bot shutdown complete")


# ==== Flask Setup ====
app = Flask(__name__)


@app.route('/')
def home():
    return "Bot is alive!"


@app.route('/health')
def enhanced_health():
    """Enhanced health check with detailed status"""
    status = {"status": "healthy", "timestamp": time.time()}

    try:
        # Test database
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM users")
            user_count = cursor.fetchone()[0]
            status["database"] = "healthy"
            status["user_count"] = user_count

        # Test bot status
        status["bot_connected"] = bot.is_ready()
        status["guilds_count"] = len(bot.guilds) if bot.guilds else 0

        # API status
        status["circuit_breaker"] = api_circuit_breaker.state.value
        status[
            "rate_limit_remaining"] = discord_rate_limiter.max_requests - len(
                discord_rate_limiter.requests)

        # Memory usage (optional - only if psutil is available)
        try:
            import psutil
            process = psutil.Process()
            status["memory_mb"] = round(
                process.memory_info().rss / 1024 / 1024, 1)
            status["cpu_percent"] = process.cpu_percent()
        except ImportError:
            status["memory_info"] = "psutil not available"

        return status, 200

    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e),
            "timestamp": time.time()
        }, 503


# ==== Discord Bot Setup ====
intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents, help_command=None)  # Overwrite the None placeholder
last_gamble_times = {}


# ==== Background Task for Temp Admin Management ====
@tasks.loop(minutes=5)
async def remove_expired_items():
    """Remove expired temp admin roles and name changes"""
    # Handle temp admins
    temp_admins = get_temp_admins()
    now = datetime.datetime.now(timezone.utc)

    for admin_data in temp_admins:
        expire_time = datetime.datetime.fromisoformat(admin_data["expires_at"])
        if now >= expire_time:
            try:
                guild = bot.get_guild(int(admin_data["guild_id"]))
                if guild:
                    member = guild.get_member(int(admin_data["user_id"]))
                    role = guild.get_role(ROLE_ID_TEMP_ADMIN)
                    if member and role:
                        result, error = await safe_remove_roles(member, role)
                remove_temp_admin(admin_data["user_id"])
            except Exception as e:
                logger.error(f"Error removing temp admin role: {e}")

    # Handle name changes
    active_name_changes = get_active_name_changes()

    for change in active_name_changes:
        expire_time = datetime.datetime.fromisoformat(change["expires_at"])
        if now >= expire_time:
            try:
                guild = bot.get_guild(int(change["guild_id"]))
                if guild:
                    member = guild.get_member(int(change["target_id"]))
                    if member:
                        original_nick = change["original_nickname"]
                        if original_nick == "None":
                            original_nick = None
                        await member.edit(nick=original_nick,
                                          reason="Name change card expired")

                remove_name_change_card(change["id"])
                logger.info(
                    f"‚úÖ Name change expired for user {change['target_id']}")

            except Exception as e:
                logger.error(f"‚ùå Error restoring nickname: {e}")


# ==== Bot Events ====
@bot.event
async def on_ready():
    print(f"‚úÖ Logged in as {bot.user}")
    logger.info(f"‚úÖ Bot logged in as {bot.user}")

    # Start background tasks
    if not remove_expired_items.is_running():
        remove_expired_items.start()
    if not auto_backup.is_running():
        auto_backup.start()
    if not monthly_conversion_check.is_running():
        monthly_conversion_check.start()
    if not api_health_monitor.is_running():
        api_health_monitor.start()

    logger.info("‚úÖ All background tasks started")

    # Try to create initial backup
    try:
        if github_backup:
            backup_file = create_backup_with_cloud_storage()
            if backup_file:
                success, result = github_backup.upload_backup_to_github(
                    backup_file)
                if success:
                    logger.info("‚úÖ Initial backup created on startup")
    except Exception as e:
        logger.error(f"‚ùå Initial backup failed: {e}")


@bot.event
async def on_error(event, *args, **kwargs):
    logger.error(f"‚ùå Error in event {event}: {args}")


@bot.event
async def on_command_error(ctx, error):
    """Enhanced error handler with better user experience"""

    # Log all errors for debugging
    logger.error(f"Command error in {ctx.command}: {error}", exc_info=True)

    # Don't handle cooldowns (decorator handles this)
    if isinstance(error, commands.CommandOnCooldown):
        return

    # Create base embed for all errors
    embed = discord.Embed(color=0xFF0000)

    if isinstance(error, commands.MissingPermissions):
        embed.title = "üö´ **INSUFFICIENT PERMISSIONS**"
        embed.description = "```diff\n- Administrator access required\n```"

    elif isinstance(error, commands.MissingRequiredArgument):
        embed.title = "‚ùå **MISSING ARGUMENT**"
        embed.description = f"```diff\n- Missing: {error.param.name}\n+ Use !help for examples\n```"

    elif isinstance(error, commands.BadArgument):
        embed.title = "‚ö†Ô∏è **INVALID ARGUMENT**"
        embed.description = "```diff\n- Check your input format\n+ Use !help for examples\n```"

    elif isinstance(error, commands.CommandNotFound):
        # Suggest similar commands
        available_commands = [cmd.name for cmd in bot.commands]
        similar = [
            cmd for cmd in available_commands if error.args[0].lower() in cmd
        ]

        if similar:
            embed.title = "‚ùì **UNKNOWN COMMAND**"
            embed.description = f"```diff\n- Command not found\n+ Similar: {', '.join(similar[:3])}\n```"
            await ctx.send(embed=embed, delete_after=10)
        return  # Don't show error for unknown commands without suggestions

    else:
        embed.title = "üí• **SYSTEM ERROR**"
        embed.description = "```diff\n- An unexpected error occurred\n+ Please try again or contact support\n```"

    try:
        await ctx.send(embed=embed, delete_after=15)
    except Exception as e:
        logger.exception(f"An unexpected error occurred: {e}")
        # Fallback to simple text if embed fails
        try:
            await ctx.send("‚ùå An error occurred. Please try again.",
                           delete_after=10)
        except Exception as e:
            logger.exception(f"An unexpected error occurred: {e}")
            pass  # Ultimate fallback - just log it


@bot.event
async def on_member_update(before, after):
    """Prevent nickname changes for users with nickname locks"""
    if before.nick != after.nick:
        if is_nickname_locked(str(after.id)):
            try:
                await after.edit(nick=before.nick,
                                 reason="Nickname locked by user")
            except discord.Forbidden:
                pass


# ==== Commands ====
@bot.command()
@safe_command_wrapper
@cooldown_check('daily')
async def daily(ctx):
    try:
        user_id = str(ctx.author.id)
        now = datetime.datetime.now(timezone.utc)
        user_data = get_user_data(user_id)

        last_claim = user_data.get("last_claim")
        streak = user_data.get("streak", 0)
        base_reward = 300

        # Check user roles by ID and set reward accordingly
        user_role_ids = [role.id for role in ctx.author.roles]

        if ROLE_ID_ADMIN in user_role_ids:
            base_reward = 400
            role_bonus = "üëë **ADMIN BLESSING** (+100 SP)"
        elif ROLE_ID_HMW in user_role_ids:
            base_reward = 350
            role_bonus = "‚ö° **HMW PRIVILEGE** (+50 SP)"
        elif ROLE_ID_BOOSTER in user_role_ids:
            base_reward = 350
            role_bonus = "üíé **BOOSTER BONUS** (+50 SP)"
        else:
            role_bonus = "üî∞ **STANDARD RATE**"

        if last_claim:
            # FIX: Ensure last_time is timezone-aware
            try:
                last_time = datetime.datetime.fromisoformat(last_claim)
                # If the datetime doesn't have timezone info, assume UTC
                if last_time.tzinfo is None:
                    last_time = last_time.replace(tzinfo=timezone.utc)
            except ValueError:
                # Handle old datetime format without timezone
                last_time = datetime.datetime.strptime(last_claim,
                                                       "%Y-%m-%d %H:%M:%S.%f")
                last_time = last_time.replace(tzinfo=timezone.utc)

            delta = (now - last_time).days
            if delta == 0:
                remaining = 24 - (now - last_time).seconds // 3600
                embed = discord.Embed(
                    title="‚è∞ **TEMPORAL LOCK ACTIVE**",
                    description=
                    f"```diff\n- ENERGY RESERVES DEPLETED\n+ Regeneration in {remaining}h\n```\nüåü *The cosmic energy needs time to flow through your soul...*",
                    color=0x2B2D42)
                embed.set_footer(text="‚ö° Daily energy recharging...",
                                 icon_url=ctx.author.avatar.url
                                 if ctx.author.avatar else None)
                return await ctx.send(embed=embed)
            elif delta == 1:
                streak += 1
            else:
                streak = 1
        else:
            streak = 1

        reward = base_reward * 2 if streak == 5 else base_reward
        if streak == 5:
            streak = 0

        # Update user data
        old_sp = user_data.get('sp', 0)
        new_sp = old_sp + reward

        update_user_data(user_id,
                         sp=new_sp,
                         last_claim=now.isoformat(),
                         streak=streak)

        # Log transaction
        log_transaction(user_id, "daily_claim", reward, old_sp, new_sp,
                        f"Daily claim with {role_bonus}")

        # Dynamic progress bar with better styling - Red to Green progression
        streak_emojis = ['üü•', 'üü•', 'üüß', 'üü®',
                         'üü©']  # Red -> Orange -> Yellow -> Green
        bar = ''.join([
            streak_emojis[min(i, 4)] if i < streak else 'üü•' for i in range(5)
        ])

        embed = discord.Embed(
            title="‚ö° **DAILY ENERGY HARVESTED** ‚ö°",
            description=
            "```css\n[SPIRITUAL ENERGY CHANNELING COMPLETE]\n```\nüí´ *The universe grants you its power...*",
            color=0x8A2BE2 if streak >= 3 else 0x4169E1)

        embed.add_field(
            name="üéÅ **REWARDS CLAIMED**",
            value=f"```diff\n+ {reward:,} Spirit Points\n```\n{role_bonus}",
            inline=False)

        embed.add_field(
            name="üî• **STREAK PROGRESSION**",
            value=
            f"{bar} `{streak}/5`\n{'üåü *STREAK BONUS ACTIVE!*' if streak >= 3 else 'üí™ *Keep the momentum going!*'}",
            inline=False)

        embed.set_thumbnail(
            url=ctx.author.avatar.url if ctx.author.avatar else None)
        embed.set_footer(
            text=
            f"‚ö° Next claim available in 24 hours ‚Ä¢ {ctx.author.display_name}",
            icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

        result, error = await safe_send(ctx, embed=embed)
        if error:
            logger.error(f"‚ùå Failed to send message: {error}")

    except Exception as e:
        logger.error(f"‚ùå Daily command error: {e}")
        await ctx.send("‚ùå An error occurred while processing your daily claim."
                       )


@bot.command()
@commands.has_permissions(administrator=True)
async def forceconvert(ctx):
    """Manually trigger monthly conversion (Admin only)"""
    embed = discord.Embed(
        title="‚ö†Ô∏è **FORCE CONVERSION WARNING** ‚ö†Ô∏è",
        description=("```diff\n! MANUAL MONTHLY CONVERSION TRIGGER !\n```\n"
                     "üî• **THIS WILL:**\n"
                     "‚Ä¢ Convert ALL users' SP to SS immediately\n"
                     "‚Ä¢ Reset everyone's SP to 100\n"
                     "‚Ä¢ Clear monthly gambling stats\n"
                     "‚Ä¢ Cannot be undone!\n\n"
                     "React with ‚úÖ to proceed or ‚ùå to cancel."),
        color=0xFF6B00)

    message = await ctx.send(embed=embed)
    await message.add_reaction("‚úÖ")
    await message.add_reaction("‚ùå")

    def check(reaction, user):
        return (user == ctx.author and str(reaction.emoji) in ["‚úÖ", "‚ùå"]
                and reaction.message.id == message.id)

    try:
        reaction, user = await bot.wait_for('reaction_add',
                                            timeout=30.0,
                                            check=check)

        if str(reaction.emoji) == "‚úÖ":
            embed = discord.Embed(
                title="üîÑ **PROCESSING CONVERSION...**",
                description=
                "```css\n[MANUAL CONVERSION IN PROGRESS]\n```\n‚öóÔ∏è *Converting all spiritual energy to eternal stones...*",
                color=0xFFAA00)

            await message.edit(embed=embed)

            total_converted, user_count = await perform_monthly_conversion()

            if total_converted > 0:
                embed = discord.Embed(
                    title="‚úÖ **CONVERSION COMPLETE**",
                    description=
                    "```fix\n‚óÜ MANUAL MONTHLY CONVERSION SUCCESSFUL ‚óÜ\n```\nüíé *All spiritual energy has been crystallized!*",
                    color=0x00FF00)

                embed.add_field(
                    name="üìä **CONVERSION STATISTICS**",
                    value=
                    f"```yaml\nUsers Processed: {user_count:,}\nTotal SP Converted: {total_converted:,}\nConversion Rate: 1:1\nSP Reset To: 100\n```",
                    inline=False)

                embed.add_field(
                    name="üîß **ADMINISTRATOR**",
                    value=
                    f"```ansi\n\u001b[0;36m{ctx.author.display_name}\u001b[0m\n```",
                    inline=True)

                embed.set_footer(
                    text="üí´ Manual conversion completed by administrator")
            else:
                embed = discord.Embed(
                    title="‚ÑπÔ∏è **NO CONVERSION NEEDED**",
                    description="```yaml\nNo users had SP to convert\n```",
                    color=0x87CEEB)
        else:
            embed = discord.Embed(
                title="‚ùå **CONVERSION CANCELLED**",
                description=
                "```css\n[MANUAL CONVERSION ABORTED]\n```\nüõ°Ô∏è *No changes made to user balances.*",
                color=0x808080)

    except asyncio.TimeoutError:
        embed = discord.Embed(
            title="‚è∞ **TIMEOUT**",
            description=
            "```css\n[CONVERSION TIMEOUT]\n```\nüïê *No response received. Conversion cancelled.*",
            color=0x808080)

    await message.edit(embed=embed)


@bot.command()
@safe_command_wrapper
@cooldown_check('nextconvert')
async def nextconvert(ctx):
    """Show when the next monthly conversion will happen"""
    now = datetime.datetime.now(timezone.utc)

    # Calculate next conversion date
    if now.day == 1 and now.hour == 0:
        next_conversion = "üîÑ **HAPPENING NOW!**"
        time_remaining = "Conversion in progress..."
    else:
        # Next month, 1st day
        if now.month == 12:
            next_month = now.replace(year=now.year + 1,
                                     month=1,
                                     day=1,
                                     hour=0,
                                     minute=0,
                                     second=0,
                                     microsecond=0)
        else:
            next_month = now.replace(month=now.month + 1,
                                     day=1,
                                     hour=0,
                                     minute=0,
                                     second=0,
                                     microsecond=0)

        time_diff = next_month - now
        days = time_diff.days
        hours = time_diff.seconds // 3600

        next_conversion = next_month.strftime("%B 1st, %Y at 00:00 UTC")
        time_remaining = f"{days} days, {hours} hours"

    embed = discord.Embed(
        title="üóìÔ∏è **MONTHLY CONVERSION SCHEDULE** üóìÔ∏è",
        description=
        "```css\n[AUTOMATIC SP ‚Üí SS CONVERSION]\n```\n‚è∞ *When the cosmic cycle completes, all energy crystallizes...*",
        color=0x4169E1)

    embed.add_field(name="üìÖ **NEXT CONVERSION**",
                    value=f"```fix\n{next_conversion}\n```",
                    inline=False)

    embed.add_field(name="‚è≥ **TIME REMAINING**",
                    value=f"```yaml\n{time_remaining}\n```",
                    inline=True)

    embed.add_field(
        name="‚öóÔ∏è **WHAT HAPPENS?**",
        value=
        "```diff\n+ All Spirit Points ‚Üí Spirit Stones\n+ SP resets to 100 for everyone\n+ Monthly stats reset\n+ Automatic backup created\n```",
        inline=False)

    embed.add_field(
        name="üí° **PRO TIP**",
        value=
        "```fix\nSP converts automatically - no action needed!\nYour SS balance is permanent storage.\n```",
        inline=False)

    embed.set_footer(
        text=
        "üí´ Monthly conversion happens automatically on the 1st of each month",
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@commands.has_permissions(administrator=True)
async def cloudbackup(ctx):
    """Create a manual backup with GitHub cloud storage"""
    embed = discord.Embed(
        title="‚òÅÔ∏è **Creating Cloud Backup...**",
        description=
        "```css\n[SPIRITUAL DATABASE PRESERVATION RITUAL]\n```\nüíæ *Crystallizing the cosmic data into eternal storage...*",
        color=0x00FFAA)

    message = await ctx.send(embed=embed)

    try:
        # Create local backup first
        backup_file = create_backup_with_cloud_storage()

        if backup_file:
            # Try to upload to GitHub
            github_success = False
            github_error = "Not configured"

            if github_backup:
                # Update embed to show GitHub upload in progress
                embed.description = "```css\n[UPLOADING TO GITHUB CLOUD STORAGE]\n```\n‚òÅÔ∏è *Transferring cosmic data to the eternal vault...*"
                await message.edit(embed=embed)

                success, result = github_backup.upload_backup_to_github(
                    backup_file)
                if success:
                    github_success = True
                else:
                    github_error = result

            # Create final success embed
            embed = discord.Embed(
                title="‚úÖ **Cloud Backup Created**",
                description=
                "```fix\n‚óÜ COSMIC DATA PRESERVATION COMPLETE ‚óÜ\n```\nüíé *Database backup created and processed!*",
                color=0x00FF00)

            embed.add_field(
                name="üìÅ **Local File**",
                value=f"```yaml\nüíæ {os.path.basename(backup_file)}\n```",
                inline=True)

            # GitHub status
            if github_success:
                embed.add_field(name="‚òÅÔ∏è **GitHub Cloud**",
                                value="```diff\n+ ‚úÖ Uploaded to GitHub\n```",
                                inline=True)
            else:
                embed.add_field(
                    name="‚òÅÔ∏è **GitHub Cloud**",
                    value=
                    f"```diff\n- ‚ùå Upload failed\n- {github_error[:50]}...\n```",
                    inline=True)

            # Database statistics
            file_size = os.path.getsize(backup_file)
            embed.add_field(
                name="üìä **Backup Statistics**",
                value=
                f"```yaml\nTables Backed Up: 5\nFile Size: {file_size:,} bytes\nTimestamp: {datetime.datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC\nLocation: {'GitHub + Local' if github_success else 'Local Only'}\n```",
                inline=False)

            embed.set_footer(
                text=
                "üí´ Your cosmic data is now safely preserved in the eternal vault",
                icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
        else:
            embed = discord.Embed(
                title="‚ùå **Backup Failed**",
                description=
                "```diff\n- COSMIC ERROR DETECTED\n```\nüíÄ *Failed to create backup. Check logs for details.*",
                color=0xFF0000)

    except Exception as e:
        embed = discord.Embed(
            title="‚ùå **Backup Error**",
            description=
            f"```diff\n- RITUAL INTERRUPTED\n```\nüíÄ *An error occurred: {str(e)[:100]}...*",
            color=0xFF0000)

    await message.edit(embed=embed)


def validate_discord_input(text, max_length=2000, allow_mentions=False):
    """Validates Discord input to prevent common issues."""
    if not isinstance(text, str):
        return False, "Input must be a string."

    if len(text) > max_length:
        return False, f"Input exceeds maximum length of {max_length} characters."

    if not allow_mentions and ("@" in text or "<@!" in text or "<@" in text):
        return False, "Mentions are not allowed in this input."

    # Add more checks as needed (e.g., profanity filter, disallowed characters)

    return True, None


@bot.command()
@safe_command_wrapper
@cooldown_check('usename')
async def usename(ctx, member: discord.Member, *, new_nickname: str):
    """Use a name change card on someone"""

    # ADD INPUT VALIDATION
    is_valid, error_msg = validate_discord_input(new_nickname,
                                                 max_length=32,
                                                 allow_mentions=False)
    if not is_valid:
        embed = discord.Embed(title="‚ùå **INVALID NICKNAME**",
                              description=f"```diff\n- {error_msg}\n```",
                              color=0xFF0000)
        return await ctx.send(embed=embed)

    # Check if target has nickname lock
    if is_nickname_locked(str(member.id)):
        embed = discord.Embed(
            title="üîí **TARGET PROTECTED**",
            description=
            "```diff\n- Target has nickname lock active\n+ Cannot change protected nicknames\n```",
            color=0xFF6347)
        result, error = await safe_send(ctx, embed=embed)
        return

    # Check nickname length and validity
    if len(new_nickname) > 32:
        embed = discord.Embed(
            title="‚ùå **NICKNAME TOO LONG**",
            description="```diff\n- Maximum 32 characters allowed\n```",
            color=0xFF0000)
        result, error = await safe_send(ctx, embed=embed)
        return

    try:
        # Store original nickname
        original_nick = member.nick if member.nick else str(
            member.display_name)

        # Change the nickname
        await member.edit(
            nick=new_nickname,
            reason=f"Name change card used by {ctx.author.display_name}")

        # Deduct cost and record the change
        user_id = str(ctx.author.id)  # Add this line to get user_id
        user_data = get_user_data(user_id)  # Add this line to get user_data
        new_balance = user_data["balance"] - 10000
        update_user_data(user_id, balance=new_balance)

        # Set expiry (24 hours from now)
        expires_at = (datetime.datetime.now(timezone.utc) +
                      timedelta(hours=24)).isoformat()

        # Record the name change
        add_name_change_card(user_id, str(member.id), original_nick,
                             new_nickname, expires_at, str(ctx.guild.id))

        # Log transaction
        log_transaction(user_id, "name_change_card", -10000,
                        user_data["balance"], new_balance,
                        f"Used name change card on {member.display_name}")

        embed = discord.Embed(
            title="üÉè **NAME CHANGE CARD ACTIVATED** üÉè",
            description=
            "```fix\n‚óÜ IDENTITY MANIPULATION SUCCESSFUL ‚óÜ\n```\n‚ú® *Reality bends to your will...*",
            color=0xFF1493)

        embed.add_field(
            name="üéØ **TARGET**",
            value=f"```ansi\n\u001b[0;36m{member.display_name}\u001b[0m\n```",
            inline=True)

        embed.add_field(
            name="üîÑ **NAME CHANGE**",
            value=f"```diff\n- {original_nick}\n+ {new_nickname}\n```",
            inline=True)

        embed.add_field(name="‚è∞ **DURATION**",
                        value="```yaml\n24 Hours\n```",
                        inline=True)

        embed.add_field(name="üí∏ **COST**",
                        value="```diff\n- 10,000 Spirit Stones\n```",
                        inline=False)

        embed.set_footer(
            text="üÉè Name will automatically revert after 24 hours",
            icon_url=ctx.author.avatar.url if ctx.author.avatar else None)

        result, error = await safe_send(ctx, embed=embed)
        if error:
            logger.error(f"‚ùå Failed to send message: {error}")

    except discord.Forbidden:
        embed = discord.Embed(
            title="üö´ **PERMISSION DENIED**",
            description=
            "```diff\n- Bot lacks permission to change nicknames\n+ Check bot role hierarchy\n```",
            color=0xFF0000)
        await ctx.send(embed=embed)

    except Exception as e:
        logger.error(f"‚ùå Name change error: {e}")
        embed = discord.Embed(
            title="‚ùå **NAME CHANGE FAILED**",
            description=
            "```diff\n- An error occurred\n+ Please try again later\n```",
            color=0xFF0000)
        await ctx.send(embed=embed)


@bot.command()
@safe_command_wrapper
@cooldown_check('sendsp')
async def sendsp(ctx, member: discord.Member, amount: int):
    """Send Spirit Points to another user (Owner only)"""
    try:
        # Check if user has the Owner role
        user_role_ids = [role.id for role in ctx.author.roles]
        if ROLE_ID_OWNER not in user_role_ids:
            embed = discord.Embed(
                title="üëë **OWNER ACCESS REQUIRED** üëë",
                description=(
                    "```diff\n"
                    "- COSMIC AUTHORITY INSUFFICIENT\n"
                    "- Only the realm Owner may grant Spirit Points\n"
                    "```\n"
                    "‚ö° *This power belongs to the supreme ruler alone...*"),
                color=0xFF0000)
            return await ctx.send(embed=embed)

        # Validate amount
        if amount <= 0:
            embed = discord.Embed(
                title="‚ùå **INVALID AMOUNT** ‚ùå",
                description=("```diff\n"
                             "- ERROR: Amount must be positive\n"
                             "+ Enter a valid positive number\n"
                             "```"),
                color=0xFF4500)
            return await ctx.send(embed=embed)

        # Add maximum amount check to prevent abuse
        if amount > 1000000:  # Adjust limit as needed
            embed = discord.Embed(
                title="‚ö†Ô∏è **AMOUNT TOO LARGE** ‚ö†Ô∏è",
                description=("```diff\n"
                             "- ERROR: Amount exceeds maximum limit\n"
                             "+ Maximum: 1,000,000 SP per transaction\n"
                             "```"),
                color=0xFF4500)
            return await ctx.send(embed=embed)

        # Check if member is bot
        if member.bot:
            embed = discord.Embed(
                title="ü§ñ **INVALID TARGET** ü§ñ",
                description="```diff\n- Cannot grant SP to bots\n```",
                color=0xFF4500)
            return await ctx.send(embed=embed)

        # Get receiver data
        receiver_id = str(member.id)
        receiver_data = get_user_data(receiver_id)
        old_sp = receiver_data.get("sp", 0)  # Use .get() for safety
        new_sp = old_sp + amount

        # Update receiver's SP
        update_user_data(receiver_id, sp=new_sp)

        # Log transaction
        log_transaction(receiver_id, "owner_sp_grant", amount, old_sp, new_sp,
                        f"SP grant by Owner {ctx.author.display_name}")

        # Success embed
        embed = discord.Embed(
            title="üëë **DIVINE SP BLESSING GRANTED** üëë",
            description=("```fix\n"
                         "‚ö° SUPREME OWNER AUTHORITY ACTIVATED ‚ö°\n"
                         "```\n"
                         "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                         "*‚ú® The Owner channels raw spiritual energy ‚ú®*"),
            color=0x9932CC)

        embed.add_field(
            name="üëë **SUPREME OWNER**",
            value=
            f"```ansi\n\u001b[0;35m{ctx.author.display_name}\u001b[0m\n```",
            inline=True)

        embed.add_field(
            name="üéØ **BLESSED RECIPIENT**",
            value=f"```ansi\n\u001b[0;36m{member.display_name}\u001b[0m\n```",
            inline=True)

        embed.add_field(name="‚ö° **SPIRIT POINTS GRANTED**",
                        value=f"```yaml\n‚ö° +{amount:,} Spirit Points\n```",
                        inline=False)

        embed.add_field(name="üîã **NEW SP BALANCE**",
                        value=f"```fix\n‚ö° {new_sp:,} SP\n```",
                        inline=False)

        embed.add_field(
            name="üåü **DIVINE BLESSING**",
            value=("```css\n"
                   "[Raw spiritual energy flows from the cosmic throne]\n"
                   "```\n"
                   "üí´ *The Owner's will shapes reality itself...*"),
            inline=False)

        embed.set_footer(
            text="üëë Supreme Owner Privilege ‚Ä¢ Spirit Point Grant System",
            icon_url=ctx.author.avatar.url if ctx.author.avatar else None)

        # Use modern datetime
        embed.timestamp = datetime.datetime.now(timezone.utc)

        # Send the embed
        result, error = await safe_send(ctx, embed=embed)
        if error:
            logger.error(f"‚ùå Failed to send message: {error}")

    except Exception as e:
        logger.error(f"‚ùå Error in sendsp command: {e}")
        error_embed = discord.Embed(
            title="‚ùå **SYSTEM ERROR** ‚ùå",
            description="```diff\n- An unexpected error occurred\n```",
            color=0xFF0000)
        await ctx.send(embed=error_embed)


@bot.command()
@safe_command_wrapper
@commands.has_permissions(administrator=True)
async def restorebackup(ctx):
    """Restore database from cloud backup (GitHub or local)"""
    embed = discord.Embed(
        title="‚ö†Ô∏è **Restore Confirmation**",
        description=
        ("```diff\n+ COSMIC DATABASE RESTORATION RITUAL +\n```\n"
         "‚ö†Ô∏è *This will replace your current database with the latest backup.*\n"
         "üî• ***ALL CURRENT DATA WILL BE LOST!***\n\n"
         "React with ‚úÖ to confirm or ‚ùå to cancel."),
        color=0xFFB800)

    embed.add_field(
        name="üõ°Ô∏è **Safety Measures**",
        value=
        "```yaml\nCurrent DB: Will be backed up first\nRestore Source: Latest backup (GitHub/Local)\nRollback: Possible via pre-restore backup\n```",
        inline=False)

    message = await ctx.send(embed=embed)
    await message.add_reaction("‚úÖ")
    await message.add_reaction("‚ùå")

    def check(reaction, user):
        return (user == ctx.author and str(reaction.emoji) in ["‚úÖ", "‚ùå"]
                and reaction.message.id == message.id)

    try:
        reaction, user = await bot.wait_for('reaction_add',
                                            timeout=30.0,
                                            check=check)

        if str(reaction.emoji) == "‚úÖ":
            embed = discord.Embed(
                title="üîÑ **Restoring from Cloud...**",
                description=
                "```css\n[COSMIC DATA RESTORATION IN PROGRESS]\n```\n‚ö° *Downloading and restoring backup from cloud storage...*",
                color=0xFFAA00)

            await message.edit(embed=embed)

            success = restore_from_cloud()

            if success:
                embed = discord.Embed(
                    title="‚úÖ **Restore Complete**",
                    description=
                    ("```fix\n‚óÜ COSMIC DATABASE RESTORATION SUCCESSFUL ‚óÜ\n```\n"
                     "üíé *Database has been restored from backup!*\n"
                     "‚ö° ***Bot restart recommended.***"),
                    color=0x00FF00)

                embed.add_field(
                    name="üîÑ **Next Steps**",
                    value=
                    "```yaml\n1. Bot restart recommended\n2. Verify data integrity\n3. Check all functions\n4. Old DB backed up as pre-restore\n```",
                    inline=False)
            else:
                embed = discord.Embed(
                    title="‚ùå **Restore Failed**",
                    description=
                    "```diff\n- RESTORATION RITUAL FAILED\n```\nüíÄ *Failed to restore from backup. Check logs for details.*",
                    color=0xFF0000)

        else:
            embed = discord.Embed(
                title="‚ùå **Restore Cancelled**",
                description=
                "```css\n[RESTORATION RITUAL CANCELLED]\n```\nüõ°Ô∏è *Your current database remains unchanged.*",
                color=0x808080)

    except asyncio.TimeoutError:
        embed = discord.Embed(
            title="‚è∞ **Timeout**",
            description=
            "```css\n[RESTORATION RITUAL TIMEOUT]\n```\nüïê *No response received. Current database remains unchanged.*",
            color=0x808080)

    await message.edit(embed=embed)


@bot.command()
@safe_command_wrapper
@cooldown_check('apistatus')
async def apistatus(ctx):
    """Check API usage and rate limiting status (Admin only)"""
    try:
        now = time.time()

        # Discord API stats
        api_usage = len(discord_api_calls)
        api_percentage = (api_usage / DISCORD_API_LIMIT) * 100

        # Active cooldowns
        active_cooldowns = sum(
            len(commands) for commands in user_command_cooldowns.values())

        # Most used commands in last hour
        recent_commands = defaultdict(int)
        for user_commands in user_command_cooldowns.values():
            for command, last_used in user_commands.items():
                if now - last_used < 3600:  # Last hour
                    recent_commands[command] += 1

        embed = discord.Embed(
            title="üìä **API STATUS DASHBOARD** üìä",
            description=
            "```css\n[SYSTEM PERFORMANCE ANALYSIS]\n```\nüîß *Real-time API health monitoring...*",
            color=0x00FF7F if api_percentage < 80 else
            0xFFB347 if api_percentage < 95 else 0xFF0000)

        embed.add_field(
            name="üåê **Discord API Usage**",
            value=
            f"```yaml\nCalls: {api_usage}/{DISCORD_API_LIMIT}\nUsage: {api_percentage:.1f}%\nWindow: {API_WINDOW}s\nStatus: {'üü¢ Healthy' if api_percentage < 80 else 'üü° Busy' if api_percentage < 95 else 'üî¥ Critical'}\n```",
            inline=False)

        embed.add_field(
            name="‚è∞ **Command Cooldowns**",
            value=
            f"```yaml\nActive Cooldowns: {active_cooldowns}\nUsers Affected: {len(user_command_cooldowns)}\n```",
            inline=True)

        if recent_commands:
            top_commands = sorted(recent_commands.items(),
                                  key=lambda x: x[1],
                                  reverse=True)[:5]
            command_list = "\n".join(
                [f"{cmd}: {count}" for cmd, count in top_commands])
            embed.add_field(name="üìà **Popular Commands (1h)**",
                            value=f"```\n{command_list}\n```",
                            inline=True)

        embed.set_footer(
            text="üîÑ Updates every 5 minutes ‚Ä¢ API monitoring active",
            icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

        result, error = await safe_send(ctx, embed=embed)
        if error:
            await ctx.send(f"‚ùå Error displaying API status: {error}")

    except Exception as e:
        logger.error(f"‚ùå API status command error: {e}")
        await ctx.send("‚ùå Failed to retrieve API status.")


@bot.command()
@safe_command_wrapper
@commands.has_permissions(administrator=True)
async def backupstatus(ctx):
    """Check backup status and list available backups (GitHub + Local)"""
    embed = discord.Embed(
        title="üìä **COSMIC BACKUP STATUS** üìä",
        description=
        "```css\n[BACKUP VAULT ANALYSIS]\n```\nüíæ *Examining the preservation of cosmic data...*",
        color=0x4169E1)

    try:
        # GitHub backup status
        github_backups = []
        if github_backup:
            success, github_files = github_backup.list_github_backups()
            if success and github_files:
                github_backups = github_files[:5]  # Show latest 5

                latest_github = github_files[0]
                embed.add_field(
                    name="‚òÅÔ∏è **GitHub Cloud Storage**",
                    value=
                    f"```yaml\nStatus: ‚úÖ Connected\nLatest: {latest_github['name']}\nTotal Files: {len(github_files)}\nRepository: {GITHUB_BACKUP_REPO}\n```",
                    inline=False)

                # List GitHub backups
                github_list = "\n".join(
                    [f"‚òÅÔ∏è {backup['name']}" for backup in github_backups])
                embed.add_field(name="üìã **Recent GitHub Backups**",
                                value=f"```\n{github_list}\n```",
                                inline=True)
            else:
                embed.add_field(
                    name="‚òÅÔ∏è **GitHub Cloud Storage**",
                    value="```diff\n- ‚ùå Connection failed or no backups\n```",
                    inline=False)
        else:
            embed.add_field(
                name="‚òÅÔ∏è **GitHub Cloud Storage**",
                value=
                "```diff\n- ‚ùå Not configured\n+ Set GITHUB_TOKEN and GITHUB_BACKUP_REPO\n```",
                inline=False)

        # Local backup status
        if os.path.exists("backups"):
            backup_files = [
                f for f in os.listdir("backups") if f.endswith(".db")
            ]
            backup_files.sort(
                key=lambda x: os.path.getmtime(os.path.join("backups", x)),
                reverse=True)

            if backup_files:
                latest_backup = backup_files[0]
                latest_path = os.path.join("backups", latest_backup)
                latest_time = datetime.datetime.fromtimestamp(
                    os.path.getmtime(latest_path))
                total_size = sum(
                    os.path.getsize(os.path.join("backups", f))
                    for f in backup_files)

                embed.add_field(
                    name="üíæ **Local Storage**",
                    value=
                    f"```yaml\nLatest: {latest_backup}\nCreated: {latest_time.strftime('%Y-%m-%d %H:%M:%S')}\nFiles: {len(backup_files)}\nTotal Size: {total_size:,} bytes\n```",
                    inline=True)

                # List local backups
                recent_local = backup_files[:5]
                local_list = "\n".join(
                    [f"üíæ {backup}" for backup in recent_local])
                embed.add_field(name="üìã **Recent Local Backups**",
                                value=f"```\n{local_list}\n```",
                                inline=True)
            else:
                embed.add_field(name="üíæ **Local Storage**",
                                value="```diff\n- No local backups found\n```",
                                inline=True)
        else:
            embed.add_field(name="üíæ **Local Storage**",
                            value="```diff\n- Backup directory not found\n```",
                            inline=True)

        # Current database info
        if os.path.exists(DB_FILE):
            current_size = os.path.getsize(DB_FILE)
            current_time = datetime.datetime.fromtimestamp(
                os.path.getmtime(DB_FILE))

            embed.add_field(
                name="üóÑÔ∏è **Current Database**",
                value=
                f"```yaml\nFile: {DB_FILE}\nModified: {current_time.strftime('%Y-%m-%d %H:%M:%S')}\nSize: {current_size:,} bytes\n```",
                inline=False)

    except Exception as e:
        embed.add_field(
            name="‚ùå **Error**",
            value=
            f"```diff\n- Failed to check backup status\n- Error: {str(e)[:100]}...\n```",
            inline=False)

    embed.set_footer(text="üí´ Regular backups ensure cosmic data preservation",
                     icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('ssbal')
async def ssbal(ctx, member: Optional[discord.Member] = None):
    user = member or ctx.author
    user_id = str(user.id)
    user_data = get_user_data(user_id)
    balance = user_data.get("balance", 0)

    # Wealth tier determination
    if balance >= 100000:
        tier = "üèÜ **LEGEND**"
        tier_color = 0xFFD700
    elif balance >= 50000:
        tier = "üíé **ELITE**"
        tier_color = 0x9932CC
    elif balance >= 20000:
        tier = "‚ö° **MASTER**"
        tier_color = 0x4169E1
    elif balance >= 5000:
        tier = "üåü **RISING**"
        tier_color = 0x32CD32
    else:
        tier = "üî∞ **BEGINNER**"
        tier_color = 0x708090

    embed = discord.Embed(
        title=f"üí∞ **{user.display_name.upper()}'S TREASURY** üí∞",
        description=
        f"```css\n[SPIRITUAL WEALTH ANALYSIS]\n```\n{tier} ‚Ä¢ *The crystallized power of ages...*",
        color=tier_color)

    embed.add_field(name="üíé **SPIRIT STONES**",
                    value=f"```fix\n{balance:,} SS\n```",
                    inline=True)

    embed.set_thumbnail(url=user.avatar.url if user.avatar else None)
    embed.set_footer(
        text=f"üí´ Wealth transcends mortal understanding ‚Ä¢ ID: {user.id}")

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('spbal')
async def spbal(ctx, member: Optional[discord.Member] = None):
    user = member or ctx.author
    user_id = str(user.id)
    user_data = get_user_data(user_id)
    sp = user_data.get("sp", 0)

    # Energy tier determination
    if sp >= 50000:
        energy_tier = "‚ö° **STORM**"
        energy_color = 0xFF1493
    elif sp >= 25000:
        energy_tier = "üî• **INFERNO**"
        energy_color = 0xFF4500
    elif sp >= 10000:
        energy_tier = "üí´ **RADIANT**"
        energy_color = 0x8A2BE2
    elif sp >= 2000:
        energy_tier = "üåü **BRIGHT**"
        energy_color = 0x4169E1
    else:
        energy_tier = "‚ú® **SPARK**"
        energy_color = 0x20B2AA

    embed = discord.Embed(
        title=f"‚ö° **{user.display_name.upper()}'S ENERGY CORE** ‚ö°",
        description=
        f"```diff\n+ SPIRITUAL POWER ANALYSIS +\n```\n{energy_tier} ‚Ä¢ *Raw energy flows through your essence...*",
        color=energy_color)

    embed.add_field(name="‚ö° **SPIRIT POINTS**",
                    value=f"```css\n{sp:,} SP\n```",
                    inline=True)

    embed.add_field(
        name="üîã **ENERGY FLOW**",
        value=
        f"```\n{'‚ñ∞' * (min(sp, 10000) * 15 // 10000)}{'‚ñ±' * (15 - (min(sp, 10000) * 15 // 10000))}\n```",
        inline=False)

    embed.set_thumbnail(url=user.avatar.url if user.avatar else None)
    embed.set_footer(
        text=f"üåä Energy is the source of all creation ‚Ä¢ {user.display_name}")

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('exchange')
async def exchange(ctx, amount: str):
    user_id = str(ctx.author.id)
    user_data = get_user_data(user_id)

    if amount.lower() == "all":
        exchange_amount = user_data.get("sp", 0)
    else:
        try:
            exchange_amount = int(amount)
        except ValueError:
            embed = discord.Embed(
                title="‚ùå **INVALID INPUT**",
                description=
                "```diff\n- ERROR: Invalid amount detected\n+ Use: !exchange <number> or 'all'\n```",
                color=0xFF0000)
            return await ctx.send(embed=embed)

    if exchange_amount <= 0 or exchange_amount > user_data.get("sp", 0):
        embed = discord.Embed(
            title="üö´ **INSUFFICIENT ENERGY**",
            description=
            "```css\n[TRANSACTION BLOCKED]\n```\nüíî *Your spiritual energy reserves are inadequate for this conversion...*",
            color=0xFF4500)
        return await ctx.send(embed=embed)

    # Update balances
    old_sp = user_data.get('sp', 0)
    old_balance = user_data.get('balance', 0)
    new_sp = old_sp - exchange_amount
    new_balance = old_balance + exchange_amount

    update_user_data(user_id, sp=new_sp, balance=new_balance)

    # Log transaction
    log_transaction(user_id, "exchange", exchange_amount, old_balance,
                    new_balance, f"Exchanged {exchange_amount} SP to SS")

    embed = discord.Embed(
        title="üîÑ **ENERGY TRANSMUTATION COMPLETE** üîÑ",
        description=
        "```fix\n‚óÜ SPIRITUAL ALCHEMY SUCCESSFUL ‚óÜ\n```\n‚ú® *Energy crystallizes into eternal stone...*",
        color=0x9932CC)

    embed.add_field(
        name="‚öóÔ∏è **CONVERSION RESULT**",
        value=
        f"```diff\n- {exchange_amount:,} Spirit Points\n+ {exchange_amount:,} Spirit Stones\n```",
        inline=False)

    embed.add_field(
        name="üìä **UPDATED RESERVES**",
        value=
        f"```yaml\nSP Remaining: {new_sp:,}\nSS Balance: {new_balance:,}\n```",
        inline=False)

    embed.set_footer(
        text="‚ö° Perfect 1:1 conversion rate achieved",
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('coinflip')
async def coinflip(ctx, guess: str, amount: str):
    now = datetime.datetime.now(timezone.utc)
    user_id = str(ctx.author.id)
    guess = guess.lower()

    if guess not in ["heads", "tails"]:
        embed = discord.Embed(
            title="‚ö†Ô∏è **INVALID PREDICTION**",
            description=
            "```diff\n- COSMIC ERROR DETECTED\n+ Valid options: 'heads' or 'tails'\n```\nüéØ *Choose your fate wisely, mortal...*",
            color=0xFF6347)
        return await ctx.send(embed=embed)

    user_data = get_user_data(user_id)
    sp = user_data.get("sp", 0)

    if user_id in last_gamble_times and (
            now - last_gamble_times[user_id]).total_seconds() < 60:
        embed = discord.Embed(
            title="‚è≥ **COSMIC COOLDOWN**",
            description=
            "```css\n[FATE ENERGY RECHARGING]\n```\nüåå *The universe needs time to align the cosmic forces...*",
            color=0x4682B4)
        embed.set_footer(
            text="‚ö° Gambling cooldown: 60 seconds between attempts")
        result, error = await safe_send(ctx, embed=embed)
        return

    validated_amount = validate_amount(amount, 20000)
    if validated_amount is None:
        embed = discord.Embed(
            title="üí∏ **INVALID WAGER**",
            description=
            "```diff\n- BETTING ERROR\n+ Enter a valid number or 'all'\n```",
            color=0xFF0000)
        result, error = await safe_send(ctx, embed=embed)
        return

    if validated_amount == "all":
        bet = min(sp, 20000)
    else:
        bet = validated_amount

    if bet <= 0 or bet > 20000 or bet > sp:
        embed = discord.Embed(
            title="üö´ **WAGER REJECTED**",
            description=
            "```css\n[INSUFFICIENT FUNDS OR LIMIT EXCEEDED]\n```\nüí∞ *Maximum bet: 20,000 SP*\n‚ö° *Current SP: {:,}*"
            .format(sp),
            color=0xFF4500)
        result, error = await safe_send(ctx, embed=embed)
        return

    flip = random.choice(["heads", "tails"])
    won = (flip == guess)

    if won:
        new_sp = sp + bet
        update_user_data(user_id, sp=new_sp)
        update_monthly_stats(user_id, win_amount=bet)
        log_transaction(user_id, "gambling_win", bet, sp, new_sp,
                        f"Coinflip win: {flip}")

        embed = discord.Embed(
            title="üéâ **FATE SMILES UPON YOU** üéâ",
            description=
            f"```diff\n+ COSMIC VICTORY ACHIEVED +\n```\nü™ô *The coin reveals: **{flip.upper()}***\n‚ú® *Fortune flows through your spirit...*",
            color=0x00FF00)

        embed.add_field(name="üèÜ **VICTORY SPOILS**",
                        value=f"```css\n+{bet:,} Spirit Points\n```",
                        inline=True)

        embed.add_field(name="üí∞ **NEW BALANCE**",
                        value=f"```fix\n{new_sp:,} SP\n```",
                        inline=True)
    else:
        new_sp = sp - bet
        update_user_data(user_id, sp=new_sp)
        update_monthly_stats(user_id, loss_amount=bet)
        log_transaction(user_id, "gambling_loss", -bet, sp, new_sp,
                        f"Coinflip loss: {flip}")

        embed = discord.Embed(
            title="üíÄ **THE VOID CLAIMS ITS DUE** üíÄ",
            description=
            f"```diff\n- COSMIC DEFEAT ENDURED -\n```\nü™ô *The coin reveals: **{flip.upper()}***\nüåë *Your greed feeds the endless darkness...*",
            color=0xFF0000)

        embed.add_field(name="üí∏ **LOSSES SUFFERED**",
                        value=f"```css\n-{bet:,} Spirit Points\n```",
                        inline=True)

        embed.add_field(name="üíî **REMAINING BALANCE**",
                        value=f"```fix\n{new_sp:,} SP\n```",
                        inline=True)

    last_gamble_times[user_id] = now

    embed.add_field(
        name="üéØ **PREDICTION vs REALITY**",
        value=
        f"```yaml\nYour Guess: {guess.title()}\nActual Result: {flip.title()}\nOutcome: {'WIN' if won else 'LOSS'}\n```",
        inline=False)

    embed.set_footer(
        text="üé∞ The cosmic coin never lies ‚Ä¢ Gamble responsibly",
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('shop')
async def shop(ctx):
    embed = discord.Embed(
        title="üè™ **GU CHANG'S MYSTICAL EMPORIUM** üè™",
        description=
        "```css\n[LEGENDARY ARTIFACTS AWAIT]\n```\n‚ú® *Only the worthy may claim these treasures of power...*",
        color=0xFF6B35)

    for item, details in SHOP_ITEMS.items():
        item_name = item.replace('_', ' ').title()

        embed.add_field(
            name=f"{details['desc'].split()[0]} **{item_name.upper()}**",
            value=
            f"```yaml\nPrice: {details['price']:,} Spirit Stones\n```\n*{details['desc'][2:]}*",
            inline=True)

    embed.add_field(
        name="üí≥ **PURCHASE INSTRUCTIONS**",
        value=
        "```fix\n!buy <item_name>\n```\nüõí *Use the command above to claim your artifact*",
        inline=False)

    embed.set_footer(text="‚ö° Spiritual artifacts enhance your cosmic journey",
                     icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('buy')
async def buy(ctx, item: str):
    user_id = str(ctx.author.id)
    user_data = get_user_data(user_id)

    item = item.lower()
    if item not in SHOP_ITEMS:
        available_items = ", ".join(
            [i.replace('_', ' ').title() for i in SHOP_ITEMS.keys()])
        embed = discord.Embed(
            title="‚ùå **ARTIFACT NOT FOUND**",
            description=
            f"```diff\n- UNKNOWN ITEM REQUESTED\n```\nüîç **Available Items:** {available_items}",
            color=0xFF0000)
        return await ctx.send(embed=embed)

    item_data = SHOP_ITEMS[item]
    balance = user_data["balance"]

    if balance < item_data["price"]:
        shortage = item_data["price"] - balance
        embed = discord.Embed(
            title="üí∏ **INSUFFICIENT SPIRIT STONES**",
            description=
            f"```diff\n- TREASURY INADEQUATE\n```\nüí∞ **Required:** {item_data['price']:,} SS\nüíé **You Have:** {balance:,} SS\nüìâ **Shortage:** {shortage:,} SS\n\n‚ö° *Gather more power before returning...*",
            color=0xFF6347)
        return await ctx.send(embed=embed)

    if item == "nickname_lock":
        add_nickname_lock(user_id)
        effect = "üîí **IDENTITY SEALED** - *Your name is now protected from all changes*"
        effect_color = 0x4169E1
    elif item == "temp_admin":
        expiry = datetime.datetime.now(
            timezone.utc) + datetime.timedelta(hours=1)
        add_temp_admin(user_id, expiry.isoformat(), str(ctx.guild.id))
        role = ctx.guild.get_role(ROLE_ID_TEMP_ADMIN)
        if role:
            await ctx.author.add_roles(role)
        effect = "‚ö° **TEMPORAL AUTHORITY GRANTED** - *Divine power flows through you for 1 hour*"
        effect_color = 0xFF1493
    elif item == "hmw_role":
        role = ctx.guild.get_role(ROLE_ID_HMW)
        if role:
            await ctx.author.add_roles(role)
        effect = "üëë **ELITE STATUS ACHIEVED** - *You have joined the HMW elite circle*"
        effect_color = 0xFFD700

    elif item == "name_change_card":
        # This gives them the card, they use it with a separate command
        effect = "üÉè **NAME CHANGE CARD ACQUIRED** - *Use !usename @target 'new nickname' to activate*"
        effect_color = 0xFF1493
    else:
        effect = "‚ú® **ARTIFACT BONDED** - *The power is now yours to wield*"
        effect_color = 0x9932CC

    # Update balance
    new_balance = balance - item_data["price"]
    update_user_data(user_id, balance=new_balance)

    # Log transaction
    log_transaction(user_id, "shop_purchase", -item_data["price"], balance,
                    new_balance, f"Purchased {item}")

    embed = discord.Embed(
        title="‚úÖ **TRANSACTION COMPLETED** ‚úÖ",
        description=
        f"```fix\n‚óÜ ARTIFACT ACQUISITION SUCCESSFUL ‚óÜ\n```\n{effect}",
        color=effect_color)

    embed.add_field(name="üéÅ **ARTIFACT CLAIMED**",
                    value=f"```css\n{item.replace('_', ' ').title()}\n```",
                    inline=True)

    embed.add_field(
        name="üí∞ **COST PAID**",
        value=f"```diff\n- {item_data['price']:,} Spirit Stones\n```",
        inline=True)

    embed.add_field(name="üíé **REMAINING BALANCE**",
                    value=f"```yaml\n{new_balance:,} SS\n```",
                    inline=True)

    embed.set_thumbnail(
        url=ctx.author.avatar.url if ctx.author.avatar else None)
    embed.set_footer(text="üåü Power has been transferred ‚Ä¢ Use it wisely",
                     icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
async def givess(ctx, member: discord.Member, amount: int):
    # Check if user has administrator permissions
    if not ctx.author.guild_permissions.administrator:
        embed = discord.Embed(
            title="üö´ **ACCESS DENIED** üö´",
            description=
            "```diff\n- INSUFFICIENT AUTHORITY\n- Administrator permissions required\n```\n‚ö° *Only those with divine authority may grant such power...*",
            color=0xFF0000)
        return await ctx.send(embed=embed)

    if amount <= 0:
        embed = discord.Embed(
            title="‚ùå **INVALID AMOUNT** ‚ùå",
            description=
            "```diff\n- ERROR: Amount must be positive\n+ Enter a valid positive number\n```",
            color=0xFF4500)
        return await ctx.send(embed=embed)

    receiver_id = str(member.id)
    receiver_data = get_user_data(receiver_id)
    old_balance = receiver_data["balance"]
    new_balance = old_balance + amount

    update_user_data(receiver_id, balance=new_balance)

    # Log transaction
    log_transaction(receiver_id, "admin_grant", amount, old_balance,
                    new_balance, f"Admin grant by {ctx.author.display_name}")

    embed = discord.Embed(
        title="‚ú® **DIVINE BLESSING GRANTED** ‚ú®",
        description=
        "```fix\n‚ö° ADMINISTRATOR AUTHORITY ACTIVATED ‚ö°\n```\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n*üåü The cosmic treasury flows with divine will üåü*",
        color=0x00FF7F)

    embed.add_field(
        name="üëë **ADMINISTRATOR**",
        value=f"```ansi\n\u001b[0;35m{ctx.author.display_name}\u001b[0m\n```",
        inline=True)

    embed.add_field(
        name="üéØ **RECIPIENT**",
        value=f"```ansi\n\u001b[0;36m{member.display_name}\u001b[0m\n```",
        inline=True)

    embed.add_field(name="üí∞ **AMOUNT GRANTED**",
                    value=f"```yaml\nüíé +{amount:,} Spirit Stones\n```",
                    inline=False)

    embed.add_field(name="üíé **NEW BALANCE**",
                    value=f"```fix\nüíé {new_balance:,} SS\n```",
                    inline=False)

    embed.set_footer(
        text="‚ö° Divine Administrative System ‚ö°",
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
    embed.timestamp = datetime.datetime.now(timezone.utc)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
async def takess(ctx, member: discord.Member, amount: int):
    # Check if user has administrator permissions
    if not ctx.author.guild_permissions.administrator:
        embed = discord.Embed(
            title="üö´ **ACCESS DENIED** üö´",
            description=
            "```diff\n- INSUFFICIENT AUTHORITY\n- Administrator permissions required\n```\n‚ö° *Only those with divine authority may wield such power...*",
            color=0xFF0000)
        return await ctx.send(embed=embed)

    if amount <= 0:
        embed = discord.Embed(
            title="‚ùå **INVALID AMOUNT** ‚ùå",
            description=
            "```diff\n- ERROR: Amount must be positive\n+ Enter a valid positive number\n```",
            color=0xFF4500)
        return await ctx.send(embed=embed)

    target_id = str(member.id)
    target_data = get_user_data(target_id)
    current_balance = target_data["balance"]

    if amount > current_balance:
        embed = discord.Embed(
            title="‚ö†Ô∏è **INSUFFICIENT FUNDS** ‚ö†Ô∏è",
            description=
            f"```diff\n- Cannot remove more than available\n```\nüí∞ **Target Balance:** {current_balance:,} SS\nüìâ **Requested Removal:** {amount:,} SS\n\n‚ö° *The void cannot claim what does not exist...*",
            color=0xFF6347)
        return await ctx.send(embed=embed)

    new_balance = current_balance - amount
    update_user_data(target_id, balance=new_balance)

    # Log transaction
    log_transaction(target_id, "admin_remove", -amount, current_balance,
                    new_balance, f"Admin removal by {ctx.author.display_name}")

    embed = discord.Embed(
        title="üíÄ **DIVINE JUDGMENT EXECUTED** üíÄ",
        description=
        "```fix\n‚ö° ADMINISTRATOR AUTHORITY ACTIVATED ‚ö°\n```\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n*üåë The cosmic balance demands sacrifice üåë*",
        color=0xFF1744)

    embed.add_field(
        name="üëë **ADMINISTRATOR**",
        value=f"```ansi\n\u001b[0;31m{ctx.author.display_name}\u001b[0m\n```",
        inline=True)

    embed.add_field(
        name="üéØ **TARGET**",
        value=f"```ansi\n\u001b[0;33m{member.display_name}\u001b[0m\n```",
        inline=True)

    embed.add_field(name="üí∏ **AMOUNT REMOVED**",
                    value=f"```yaml\nüíé -{amount:,} Spirit Stones\n```",
                    inline=False)

    embed.add_field(name="üíî **REMAINING BALANCE**",
                    value=f"```fix\nüíé {new_balance:,} SS\n```",
                    inline=False)

    embed.set_footer(
        text="‚ö° Divine Administrative System ‚ö°",
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None)
    embed.timestamp = datetime.datetime.now(timezone.utc)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('top')
async def top(ctx):
    leaderboard = get_leaderboard('balance', 10)

    embed = discord.Embed(
        title="üèÜ **SPIRIT STONES LEADERBOARD** üèÜ",
        description=
        "```css\n[HALL OF SPIRITUAL LEGENDS]\n```\nüíé *The most powerful cultivators in the realm...*",
        color=0xFFD700)

    medal_emojis = [
        "ü•á", "ü•à", "ü•â", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£", "üîü"
    ]

    leaderboard_text = ""
    for i, (user_id, balance) in enumerate(leaderboard):
        try:
            user = bot.get_user(int(user_id))
            username = user.display_name if user else "Unknown User"

            leaderboard_text += f"{medal_emojis[i]} **{username}** - `{balance:,}` SS\n"
        except Exception:
            continue

    if leaderboard_text:
        embed.add_field(name="üí∞ **TOP CULTIVATORS**",
                        value=leaderboard_text,
                        inline=False)
    else:
        embed.add_field(
            name="üí∞ **TOP CULTIVATORS**",
            value=
            "```diff\n- No data available yet\n+ Start cultivating to appear here!\n```",
            inline=False)

    embed.set_footer(text="‚ö° Power rankings updated in real-time",
                     icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('lucky')
async def lucky(ctx):
    """Shows total SP of top 10 players instead of individual gambling stats"""
    sp_leaderboard = get_leaderboard('sp', 10)

    total_sp = sum(sp for _, sp in sp_leaderboard)

    embed = discord.Embed(
        title="üçÄ **COSMIC FORTUNE READING** üçÄ",
        description=
        "```css\n[SPIRITUAL ENERGY ANALYSIS]\n```\n‚ö° *The combined power of the top cultivators flows through the realm...*",
        color=0x00FF7F)

    # Show top 10 SP holders
    medal_emojis = [
        "ü•á", "ü•à", "ü•â", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£", "üîü"
    ]

    leaderboard_text = ""
    for i, (user_id, sp) in enumerate(sp_leaderboard):
        try:
            user = bot.get_user(int(user_id))
            username = user.display_name if user else "Unknown User"

            leaderboard_text += f"{medal_emojis[i]} **{username}** - `{sp:,}` SP\n"
        except Exception:
            continue

    if leaderboard_text:
        embed.add_field(name="‚ö° **TOP ENERGY MASTERS**",
                        value=leaderboard_text,
                        inline=False)

    embed.add_field(
        name="üåü **COSMIC ENERGY POOL**",
        value=
        f"```fix\nüí´ {total_sp:,} Total Spirit Points\n```\n*The accumulated power of the realm's elite...*",
        inline=False)

    embed.add_field(
        name="üîÆ **FORTUNE INSIGHT**",
        value=
        f"```yaml\nAverage Power: {total_sp // 10 if sp_leaderboard else 0:,} SP\nRealm Status: {'Flourishing' if total_sp > 100000 else 'Growing' if total_sp > 50000 else 'Developing'}\n```",
        inline=False)

    embed.set_footer(
        text="üçÄ The universe reveals its secrets to those who seek",
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('unlucky')
async def unlucky(ctx):
    """Shows top 10 users who lost the most SP this month"""
    current_month = datetime.datetime.now(timezone.utc).strftime("%Y-%m")
    top_losers = get_top_losers(current_month, 10)

    if not top_losers:
        embed = discord.Embed(
            title="üåü **BLESSED MONTH** üåü",
            description=
            "```css\n[NO SIGNIFICANT LOSSES DETECTED]\n```\n‚ú® *The void has been merciful this month...*",
            color=0x32CD32)

        embed.add_field(
            name="üõ°Ô∏è **COSMIC PROTECTION**",
            value=
            "```diff\n+ No major gambling losses recorded\n+ The realm enjoys fortune's favor\n```",
            inline=False)

        embed.set_footer(
            text=
            f"üìÖ {datetime.datetime.now(timezone.utc).strftime('%B %Y')} ‚Ä¢ Keep the luck flowing!",
            icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

        return await ctx.send(embed=embed)

    total_losses = sum(losses for _, losses in top_losers)

    embed = discord.Embed(
        title="üíÄ **HALL OF COSMIC MISFORTUNE** üíÄ",
        description=
        "```css\n[THE VOID'S GREATEST VICTIMS]\n```\nüåë *Those who have fed the darkness most this month...*",
        color=0x8B0000)

    # Show top 10 losers
    skull_emojis = ["üíÄ", "‚ò†Ô∏è", "üëπ", "üòà", "üî•", "‚ö°", "üí∏", "üò≠", "üò±", "üÜò"]

    leaderboard_text = ""
    for i, (user_id, losses) in enumerate(top_losers):
        try:
            user = bot.get_user(int(user_id))
            username = user.display_name if user else "Unknown User"

            leaderboard_text += f"{skull_emojis[i]} **{username}** - `{losses:,}` SP Lost\n"
        except Exception:
            continue

    if leaderboard_text:
        embed.add_field(name="üí∏ **VOID'S FAVORED VICTIMS**",
                        value=leaderboard_text,
                        inline=False)

    embed.add_field(
        name="üåë **TOTAL DEVASTATION**",
        value=
        f"```fix\nüíÄ {total_losses:,} Spirit Points Consumed\n```\n*The accumulated suffering feeds the endless void...*",
        inline=False)

    # Calculate average loss and provide insight
    average_loss = total_losses // len(top_losers) if top_losers else 0

    if total_losses >= 500000:
        void_status = "üåë **VOID ASCENDANT** - *The darkness grows stronger with each sacrifice*"
        status_color = "Catastrophic"
    elif total_losses >= 250000:
        void_status = "üíÄ **VOID DOMINANT** - *Misfortune reigns supreme this month*"
        status_color = "Critical"
    elif total_losses >= 100000:
        void_status = "üòà **VOID ACTIVE** - *The gambling demons feast well*"
        status_color = "High"
    else:
        void_status = "üî• **VOID STIRRING** - *Minor tributes to the darkness*"
        status_color = "Moderate"

    embed.add_field(
        name="üëπ **VOID ANALYSIS**",
        value=
        f"```yaml\nAverage Loss: {average_loss:,} SP\nVoid Status: {status_color}\nMonth: {datetime.datetime.now(timezone.utc).strftime('%B %Y')}\n```\n{void_status}",
        inline=False)

    embed.add_field(
        name="‚ö†Ô∏è **COSMIC WARNING**",
        value=
        "```diff\n- The void remembers every sacrifice\n- Fortune is fickle, wisdom is eternal\n+ Practice restraint in your cosmic journey\n```",
        inline=False)

    embed.set_footer(
        text=
        f"üíÄ Monthly Misfortune Report ‚Ä¢ {datetime.datetime.now(timezone.utc).strftime('%B %Y')}",
        icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@commands.has_permissions(administrator=True)
async def errortest(ctx, error_type: str = "generic"):
    """Test error handling (Admin only)"""
    if error_type == "generic":
        raise Exception("Test error for debugging")
    elif error_type == "permission":
        raise commands.MissingPermissions(["administrator"])
    elif error_type == "argument":
        raise commands.MissingRequiredArgument(
            commands.Parameter("test",
                               commands.Parameter.POSITIONAL_OR_KEYWORD))
    else:
        await ctx.send("Available error types: generic, permission, argument")


@bot.command()
@safe_command_wrapper
@cooldown_check('lose')
async def lose(ctx, member: Optional[discord.Member] = None):
    """Shows SP lost this month for the user or tagged member"""
    user = member or ctx.author
    user_id = str(user.id)

    # Get current month stats
    current_month = datetime.datetime.now(timezone.utc).strftime("%Y-%m")
    monthly_stats = get_monthly_stats(user_id, current_month)

    losses = monthly_stats.get("losses", 0)
    wins = monthly_stats.get("wins", 0)
    net_result = wins - losses

    # Determine loss tier and color
    if losses >= 100000:
        loss_tier = "üíÄ **VOID TOUCHED**"
        tier_color = 0x8B0000
    elif losses >= 50000:
        loss_tier = "üî• **RECKLESS**"
        tier_color = 0xFF4500
    elif losses >= 25000:
        loss_tier = "‚ö†Ô∏è **DANGEROUS**"
        tier_color = 0xFF6347
    elif losses >= 10000:
        loss_tier = "üò¨ **RISKY**"
        tier_color = 0xFFB347
    elif losses > 0:
        loss_tier = "üéØ **CAUTIOUS**"
        tier_color = 0xFFD700
    else:
        loss_tier = "üõ°Ô∏è **UNTOUCHED**"
        tier_color = 0x32CD32

    embed = discord.Embed(
        title=f"üí∏ **{user.display_name.upper()}'S VOID TRIBUTE** üí∏",
        description=
        f"```css\n[MONTHLY GAMBLING ANALYSIS]\n```\n{loss_tier} ‚Ä¢ *The darkness remembers every sacrifice...*",
        color=tier_color)

    embed.add_field(name="üíÄ **LOSSES TO THE VOID**",
                    value=f"```diff\n- {losses:,} Spirit Points\n```",
                    inline=True)

    embed.add_field(name="üèÜ **GAINS FROM FORTUNE**",
                    value=f"```diff\n+ {wins:,} Spirit Points\n```",
                    inline=True)

    embed.add_field(
        name="‚öñÔ∏è **NET RESULT**",
        value=
        f"```{'diff' if net_result >= 0 else 'css'}\n{'+ ' if net_result >= 0 else ''}{net_result:,} Spirit Points\n```",
        inline=False)

    # Loss ratio calculation
    total_gambled = wins + losses
    if total_gambled > 0:
        loss_percentage = (losses / total_gambled) * 100
        embed.add_field(
            name="üìä **GAMBLING STATISTICS**",
            value=
            f"```yaml\nTotal Gambled: {total_gambled:,} SP\nLoss Rate: {loss_percentage:.1f}%\nRisk Level: {'HIGH' if loss_percentage > 60 else 'MODERATE' if loss_percentage > 40 else 'LOW'}\n```",
            inline=False)

    # Motivational message based on performance
    if net_result > 0:
        message = "üåü *Fortune favors your bold spirit!*"
    elif net_result == 0:
        message = "‚öñÔ∏è *Perfect balance - the universe is neutral.*"
    else:
        message = "üåë *The void grows stronger with your offerings...*"

    embed.add_field(name="üîÆ **COSMIC INSIGHT**", value=message, inline=False)

    embed.set_thumbnail(url=user.avatar.url if user.avatar else None)
    embed.set_footer(
        text=
        f"üìÖ {datetime.datetime.now(timezone.utc).strftime('%B %Y')} ‚Ä¢ Gamble responsibly",
        icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


@bot.command()
@safe_command_wrapper
@cooldown_check('help')
async def help(ctx):
    """Display all available commands"""
    embed = discord.Embed(
        title="üìö **GU CHANG'S CULTIVATION MANUAL** üìö",
        description=
        "```css\n[COMPLETE COMMAND REFERENCE]\n```\n‚ö° *Master these commands to ascend in power...*",
        color=0x9932CC)

    # Economy Commands
    embed.add_field(name="üí∞ **ECONOMY COMMANDS**",
                    value="""```
!daily - Claim daily SP (300-400 based on roles)
!ssbal [@user] - Check Spirit Stones balance
!spbal [@user] - Check Spirit Points balance
!exchange <amount|all> - Convert SP to SS (1:1)
!top - View SS leaderboard (top 10)
```""",
                    inline=False)

    # Gambling Commands
    embed.add_field(name="üé∞ **GAMBLING COMMANDS**",
                    value="""```
!coinflip <heads|tails> <amount|all> - Bet SP on coinflip
!lucky - View top 10 SP holders and total energy
!unlucky - View top 10 biggest losers this month
!lose [@user] - Check monthly gambling losses
```""",
                    inline=False)

    # Shop Commands
    embed.add_field(name="üõí **SHOP COMMANDS**",
                    value="""```
    !shop - View available items
    !buy <item> - Purchase shop items
      ‚Ä¢ nickname_lock (5,000 SS)
      ‚Ä¢ temp_admin (25,000 SS) 
      ‚Ä¢ hmw_role (50,000 SS)
      ‚Ä¢ name_change_card (10,000 SS)
    !usename @user "new nickname" - Use name change card
    ```""",
                    inline=False)

    # Admin Commands
    embed.add_field(name="üëë **ADMIN COMMANDS**",
                    value="""```
!givess <@user> <amount> - Grant Spirit Stones
!takess <@user> <amount> - Remove Spirit Stones
!sendsp <@user> <amount> - Grant Spirit Points (Owner Only)
```""",
                    inline=False)

    embed.add_field(name="‚ö° **DAILY REWARDS**",
                    value="""```yaml
Standard: 300 SP
Booster: 350 SP (+50)
HMW: 350 SP (+50)
Admin: 400 SP (+100)
Streak Bonus: 2x reward at 5-day streak
```""",
                    inline=False)

    embed.set_footer(text="üåü Master the commands, master your destiny ‚Ä¢ !help",
                     icon_url=ctx.guild.icon.url if ctx.guild.icon else None)

    result, error = await safe_send(ctx, embed=embed)
    if error:
        logger.error(f"‚ùå Failed to send message: {error}")


# ==== Flask Thread ====
def run_flask():
    port = int(os.environ.get('PORT', 8080))
    app.run(host='0.0.0.0', port=port)


# ==== Main Execution ====
if __name__ == "__main__":
    # Start Flask in a separate thread
    flask_thread = Thread(target=run_flask, daemon=True)
    flask_thread.start()
    logger.info("üåê Flask server started")

    # Run the bot with auto-restart capability
    max_restart_attempts = 10
    restart_delay = 30  # seconds between restarts

    for restart_attempt in range(max_restart_attempts):
        try:
            logger.info(
                f"üîÑ Bot startup attempt {restart_attempt + 1}/{max_restart_attempts}"
            )
            asyncio.run(main())

            # If we reach here, the bot shut down normally
            logger.info("‚úÖ Bot shut down normally")
            break

        except KeyboardInterrupt:
            logger.info("üõë Manual shutdown requested")
            break

        except Exception as e:
            logger.error(f"‚ùå Bot crashed: {e}")

            if restart_attempt < max_restart_attempts - 1:
                logger.info(f"üîÑ Restarting in {restart_delay} seconds...")
                time.sleep(restart_delay)

                # Exponential backoff for restart delay
                restart_delay = min(restart_delay * 1.5, 300)  # Max 5 minutes
            else:
                logger.error("‚ùå Max restart attempts exceeded")
